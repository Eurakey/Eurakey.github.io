[{"title":"组件化封装","path":"/2023/01/18/组件化封装/","content":"JS组件封装基本方法（以轮播图组件为例） 结构设计12345678910111213141516&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;slider-list__item--selected&quot;&gt; &lt;img src=&quot;xx.png&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot; &quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 展现效果 行为设计 API(功能) Event(控制流)123456789101112131415161718192021222324252627282930313233343536class Slider&#123; constructor(id)&#123; this.container = document.getElementById(id); this.items = this.container .querySelectorAll(&#x27;.slider-list__item, .slider-list__item--selected&#x27;); &#125; getSelectedItem()&#123; const selected = this.container .querySelector(&#x27;.slider-list__item--selected&#x27;); return selected &#125; getSelectedItemIndex()&#123; return Array.from(this.items).indexOf(this.getSelectedItem()); &#125; slideTo(idx)&#123; const selected = this.getSelectedItem(); if(selected)&#123; selected.className = &#x27;slider-list__item&#x27;; &#125; const item = this.items[idx]; if(item)&#123; item.className = &#x27;slider-list__item--selected&#x27;; &#125; &#125; slideNext()&#123; const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); &#125; slidePrevious()&#123; const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); &#125;&#125; 但是这样功能虽然实现，但是 可扩展性差，例如假如要加导航栏，既要改js，还要对应加上html和css 可复用性差，多次使用该组件需要多次复制相同的代码 如何改进？ 重构插件化解耦 将控制元素抽取成插件123registerPlugins(...plugins)&#123;//abstract &#125;; 插件与组件通过依赖注入方式建立联系123456789const pluginController = &#123;//abstract action(slider)&#123;//abstraction &#125;&#125;const pluginPrevious = &#123;//abstract&#125; 通过把组件的组成部分抽象成插件，我们只要在使用该组件时传入要注册的插件，就可以方便的实现组件的增删，并且后来如果还要编写新的插件也可以按原逻辑在原有js上增加。模板化 将HTML模板化。更易于扩展在插件的render方法中把组件的html模板化，123render()&#123; return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`;&#125;, 此时，组件的html代码只有短短一行1&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt;&lt;/div&gt; 抽象化(组件框架) 将组件通用模型抽象出来1234567891011121314class Component &#123; constructor(id, opts = &#123; name, data: [] &#125;) &#123; this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); &#125; registerPlugins(...plugins) &#123;//abstract &#125;; render(data) &#123;//abstract return &quot;&quot;; &#125;&#125; 这里把通用的组件模型抽象为一个Component类，后来增添新组件可通过extend关键字来继承这个component。 总结 组件设计的原则：封装性、正确性、复用性、扩展性 实现组件的步骤：结构设计、展现效果、行为设计 三次重构 插件化 模板化 抽象化","tags":["JS","青训营"]},{"title":"test","path":"/2023/01/16/test/","content":"kkkkkkkk","tags":["js","vue"]},{"title":"Advanced_Dom","path":"/wiki/JavaScript/Advanced_Dom.html","content":"Advanced DomHow the Dom really works?![BB93EF78E760EDFA026A6E09647E68DA](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BB93EF78E760EDFA026A6E09647E68DA.png) Selecting, Creating, and Deleting ElementsSelect1234567const queryAllButtons = document.querySelectorAll(&#x27;button&#x27;);console.log(queryAllButtons); // NodeList(9)// It is fixedconst getAllButtons = document.getElementsByTagName(&#x27;button&#x27;);console.log(getAllButtons); // HTMLCollection(9)// It updates itself as the html changes. Create12345678910111213const header = document.querySelector(&#x27;.header&#x27;);const message = document.createElement(&#x27;div&#x27;);message.classList.add(&#x27;cookie-message&#x27;);message.textContent = &#x27;We use cookied for improved functionality and analytics.&#x27;;message.innerHTML = &#x27;We use cookied for improved functionality and analytics.&lt;button class=&quot;btn btn--close-cookie&quot;&gt;Got it!&lt;/button&gt;&#x27;;header.prepend(message);header.append(message);header.after(message);header.before(message);message.remove(); Styles, Attributes and ClassesStyles123message.style.width = &#x27;120%&#x27;;console.log(message.style.width); // 120%console.log(message.style.height); // nothing Only works for the inline style. 12console.log(getComputedStyle(message)); // CSSStyleDeclarationconsole.log(getComputedStyle(message).height); // 50.6px Change the css variables 1document.documentElement.style.setProperty(&#x27;--color-primary&#x27;, &#x27;red&#x27;) Attributes12345678const logo = document.querySelector(&#x27;.nav__logo&#x27;);console.log(logo.alt); // Bankist logoconsole.log(logo.src); // http://127.0.0.1:5501/complete-javascript-course/13-Advanced-DOM-Bankist/starter/img/logo.pngconsole.log(logo.getAttribute(&#x27;src&#x27;)); // img/logo.pngconsole.log(logo.className); // nav__logologo.setAttribute(&#x27;designer&#x27;, &#x27;jonas&#x27;);console.log(logo.getAttribute(&#x27;designer&#x27;)); // jonas Data attributes 1logo.dataset Classes1234logo.classList.add(&#x27;c&#x27;);logo.classList.remove(&#x27;c&#x27;);logo.classList.toggle(&#x27;c&#x27;);logo.classList.contains(&#x27;c&#x27;); Implementing Smooth ScrollingOld school way1234567891011const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; const s1croods = section1.getBoundingClientRect(); window.scrollTo(&#123; left: s1croods.left + window.pageXOffset, top: s1croods.top + window.pageYOffset, behavior: &#x27;smooth&#x27;, &#125;);&#125;); Modern way123456const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; section1.scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;);&#125;); Type of Events and Event Handlers1234567891011121314const h1 = document.querySelector(&#x27;h1&#x27;);const alert = e =&gt; &#123; console.log(&#x27;Enter&#x27;); h1.removeEventListener(&#x27;mouseenter&#x27;, alert);&#125;;h1.addEventListener(&#x27;mouseenter&#x27;, alert);h1.addEventListener(&#x27;mouseleave&#x27;, e =&gt; &#123; console.log(&#x27;Leave&#x27;);&#125;);window.addEventListener(&#x27;keydown&#x27;, e =&gt; &#123; console.log(e);&#125;); Event Propagation_ Bubbling and CapturingEvent DelegationDom Traversing12345678910111213141516171819const h1 = document.querySelector(&#x27;h1&#x27;);//Going downwards: childconsole.log(h1.querySelectorAll(&#x27;.highlight&#x27;));console.log(h1.childNodes); // NodeList(9)console.log(h1.children); // HTMLCollection(3)h1.firstElementChild.style.color = &#x27;white&#x27;;h1.lastElementChild.style.color = &#x27;white&#x27;;// Going upwards: parentsconsole.log(h1.parentNode);console.log(h1.parentElement);h1.closest(&#x27;.header&#x27;).style.background = &#x27;var(--gradient-secondary)&#x27;;// Going sideways: siblingsconsole.log(h1.previousElementSibling);console.log(h1.nextElementSibling);console.log(h1.parentElement.children); The Intersection Observer API。。。。"},{"title":"Function","path":"/wiki/JavaScript/Functions.html","content":"FunctionsDefault ParametersWhy We Need It? If not 123456789101112const bookings = [];const createBooking = function (flightNum, numPassengers, price) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: undefined, price: undefined&#125; If you have 12345678910111213141516const bookings = [];const createBooking = function ( flightNum, numPassengers = 1, price = 199 * numPassengers) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 199&#125; If you want to skip some parameters, you can set it as undefined 12createBooking(&#x27;LH123&#x27;, undefined, 1000);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 1000&#125; How Passing Arguments Works:Value vs. ReferenceJavascript can only pass by value, no passing by reference. First-Class vs. Higher-ordered FunctionsFirst-Class Functions JavaScript treats functions as first-class citizens This means that functions are simply values Functions are just another “type” of object So we can: Store functions in variables or properties Passing functions as arguments to other functions Return functions from functions Call methods on functions Higher-Ordered FunctionsWhat is it? A function that receives another function as an argument ,that returns a new function, or both This is only possible because of first-class functions Why we need it a higher level of abstruction Functions Accepting Callback Functions123456789101112131415161718192021222324252627// Functions Accepting Callback Functionsconst oneWord = function (str) &#123; return str.replace(/ /g, &#x27;&#x27;).toLowerCase();&#125;;const upperFirstWord = function (str) &#123; const [first, ...others] = str.split(&#x27; &#x27;); return [first.toUpperCase(), ...others].join(&#x27; &#x27;);&#125;;// Higher-order functionconst transformer = function (str, fn) &#123; console.log(`Original string: $&#123;str&#125;`); console.log(`Transformed string: $&#123;fn(str)&#125;`); console.log(`Transformed by: $&#123;fn.name&#125;`);&#125;;transformer(&#x27;JavaScript is the best!&#x27;, upperFirstWord);transformer(&#x27;JavaScript is the best!&#x27;, oneWord);// JS uses callbacks all the timeconst high5 = function () &#123; console.log(&#x27;👋&#x27;);&#125;;document.body.addEventListener(&#x27;click&#x27;, high5);[&#x27;Jonas&#x27;, &#x27;Martha&#x27;, &#x27;Adam&#x27;].forEach(high5); Functions Ruturning functions12345678const greet = function (greeting) &#123; return function (name) &#123; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`); &#125;;&#125;;const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;);//Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;);//Hi, Aniya If you use the arrow function 1234const greet = greeting =&gt; name =&gt; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`);const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;); //Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;); //Hi, Aniya Call()123456789101112131415161718192021const lufthansa = &#123; airline: &#x27;Lufthansa&#x27;, iataCode: &#x27;LH&#x27;, bookings: [], book(flightNum, name) &#123; console.log( `$&#123;name&#125; booked a seat on $&#123;this.airline&#125; flight $&#123;this.iataCode&#125;$&#123;flightNum&#125;` ); this.bookings.push(&#123; flight: `$&#123;this.iataCode&#125;$&#123;flightNum&#125;`, name &#125;); &#125;,&#125;;lufthansa.book(239, &#x27;Aniya&#x27;);const eurowings = &#123; airline: &#x27;eurowings&#x27;, name: &#x27;Eurowings&#x27;, iataCode: &#x27;EW&#x27;, bookings: [],&#125;;const book = lufthansa.book;book.call(eurowings, 23, &#x27;hai&#x27;); The first argument is the object that you want the this point to.The rest argument is the rest argument that the original the function need. apply()1book.apply(eurowings, [234, &#x27;ajdfhha&#x27;]); Difference: The second argument is an array,to accept origin arguments. Same as 1book.call(eurowings,...[234, &#x27;ajdfhha&#x27;]); bind()It will return a functions in which the this is the argument you passed in. 123book.bind(eurowings)(224, &#x27;asjf&#x27;);const bookEu = book.bind(eurowings);bookEu(2323, &#x27;asjfa&#x27;); Also, you can use it just like the call()method, passing in more arguments. If you don’t want to set this, just use null. Partial applicationwe can preset some arguments Immediately Invoked Function Expressions(IIFE)123(function () &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); Or 123(() =&gt; &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); You can not call it tiwice. Data Encapsulation and Data PrivacyClosuers A function always has access to the variable enviroment(VE) of the execution context in which it was created,even after that execution context was gone. Closure has priority over the scope chain. A closure gives a function access to all the variables of its parent function, even after that parent function has returned.The function keeps a reference to its outer scope, which preserves the scope chain all the time. Examples: let f; const g = function () &#123; const a = 1; f = function () &#123; console.log(a * 3); &#125;; &#125;; g(); f();//3 setTimeout()"},{"title":"LOOP","path":"/wiki/JavaScript/Loop.html","content":"for-of and for-in1234567891011for (const item of restaurant.starterMenu) console.log(item);//Focaccia//Bruschetta//Garlic Bread//Caprese Saladfor (const index in restaurant.starterMenu) console.log(index);//0//1//2//3//4 Item is always the current element in each iteration. Index is always the current index or property name in each iteration. You can also use if-else to break or continue the loop. Acess the item and index at the same time1234567891011for (const item of restaurant.starterMenu.entries()) console.log(item);//(2) [0, &#x27;Focaccia&#x27;]//(2) [1, &#x27;Bruschetta&#x27;]//(2) [2, &#x27;Garlic Bread&#x27;]//(2) [3, &#x27;Caprese Salad&#x27;]for (const index in restaurant.starterMenu) console.log(restaurant.starterMenu[index], index);//Focaccia 0//Bruschetta 1//Garlic Bread 2//Caprese Salad 3 So you can see we used entries()method in for-of loop entries() An Array Iterator 12console.log(...restaurant.starterMenu.entries());//(2) [0, &#x27;Focaccia&#x27;] (2) [1, &#x27;Bruschetta&#x27;] (2) [2, &#x27;Garlic Bread&#x27;] (2) [3, &#x27;Caprese Salad&#x27;] Object.entries(objectName) 12console.log(Object.entries(restaurant));//(6) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2)] Each Array is composed of the key and the value. If you want to loop a objectObject.keys(objectName)This method returns an Arrary composed by the object’s property names. 12console.log(Object.keys(restaurant));//(6) [&#x27;name&#x27;, &#x27;location&#x27;, &#x27;categories&#x27;, &#x27;starterMenu&#x27;, &#x27;mainMenu&#x27;, &#x27;openingHours&#x27;] Object.values(objectName)This method returns an Arrary composed by the object’s property values. 12console.log(Object.values(restaurant));//(6) [&#x27;Classico Italiano&#x27;, &#x27;Via Angelo Tavanti 23, Firenze, Italy&#x27;, Array(4), Array(4), Array(3), &#123;…&#125;]"},{"title":"Array","path":"/wiki/JavaScript/Array.html","content":"ArraySimple Array Methods slice() It does not change the original array. splice() It changes the original array. 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr.splice(2)); //(3) [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]console.log(arr); //(2) [&#x27;a&#x27;, &#x27;b&#x27;] reverse() Change！ concat() 1let arr = arr1.concat(arr2); join() at()Similar to [] 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[0]); //aconsole.log(arr.at(0)); //a But at() can use negative index. So if we want the last element of an array. 1234let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[arr.length - 1]); //econsole.log(arr.slice(-1)[0]); //econsole.log(arr.at(-1)); //e And when you use method chaining. forEach()You can not break or continue it. We can also use it in Maps and Sets map()Map returns a new array containing the results of applying an operation on all original array elements filter()filter returns a new array containing the array elements that passed a specified test condition reduce()reduce boils (‘reduces’) all array elements down to one single value(e.g. adding all elements together 1234const maxMov = movements.reduce( (acc, mov) =&gt; (acc &lt; mov ? mov : acc), movements[0]); find()findIndex()includes()some()123console.log(movements.some(mov =&gt; mov &gt; 0));//trueconst deposit = mov =&gt; mov &gt; 0;console.log(movements.some(deposit)); //true every()Similar to some(), but need all elements satisfy the condition flat()12let arr = [[1, 2, 3], 4, 5, [6, [7, 8]]];console.log(arr.flat().flat());//(8) [1, 2, 3, 4, 5, 6, 7, 8] flatMap()Similar to map(), but flat its result. sort()Change the original array. 12345let movements = [200, 450, -400, 3000, -650, -130, 70, 1300];//return &lt; 0 , A, B//return &gt; 0 , B, Amovements.sort((a, b) =&gt; a - b);console.log(movements);//(8) [-650, -400, -130, 70, 200, 450, 1300, 3000] new Array()fill()1234const x = new Array(7);console.log(x);//(7) [空 ã7]x.fill(1, 3);console.log(x);//[空 ã3, 1, 1, 1, 1] Array.from()12const x = Array.from(&#123; length: 7 &#125;, () =&gt; 1);console.log(x);//(7) [1, 1, 1, 1, 1, 1, 1] 12const x = Array.from(&#123; length: 7 &#125;, (cur, i) =&gt; i + 1);console.log(x); //(7) [1, 2, 3, 4, 5, 6, 7] Turn NodeList into an Array. 12const movementsUI = Array.from(document.querySelectorAll(&#x27;.movements__value&#x27;));console.log(movementsUI);//(8) [div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value] Which Array Method to Use?To Mutate Original Array Add to original push() (end) unshift() (start) Remove from original pop() (end) shift() (start) splice() (any) Others reverse() sort() fill() A New Array Computed from original map() Filtered using condition filter() Portion of original slice() Adding original to other concat() Flattening the original flat() flatMap() An Array index Based on value includes() Based on test condition findIndex() An Array Element Based on test condition find() Konw if array includes Based on value includes() Based on test condition some() every() A New String Based on separator string join() To Transform to Value Based on accumulater reduce() To Just Loop Array Based on callback: foreach()"},{"title":"Complie_and_Interpret","path":"/wiki/JavaScript/Complie_and_Interpret.html","content":"Complilation先编译（compile）再执行（execute） Interpretation逐行编译，一边执行 Just-in-time(JIT) complilation现代javascript混合使用编译和解释,称为即时编译。"},{"title":"Numbers_and_Dates","path":"/wiki/JavaScript/Numbers_and_Dates.html","content":"Numbers and DatesNumbers12345678910111213141516171819202122232425262728// Number// Binary base 2 - 0 1console.log(23 === 23.0); //trueconsole.log(0.1 + 0.2); //0.30000000000000004// Conversionconsole.log(Number(&#x27;23&#x27;));console.log(+&#x27;23&#x27;);// Parsingconsole.log(Number.parseInt(&#x27;30px&#x27;, 10)); //30console.log(Number.parseInt(&#x27;e23&#x27;, 10)); //NaNconsole.log(Number.parseFloat(&#x27; 2.5rem&#x27;, 10)); //2.5// Check if value is NaNconsole.log(Number.isNaN(20)); //falseconsole.log(Number.isNaN(&#x27;20&#x27;)); //falseconsole.log(Number.isNaN(+&#x27;20d&#x27;)); //trueconsole.log(Number.isNaN(20 / 0)); //false// Check if value is numberconsole.log(Number.isFinite(20)); // trueconsole.log(Number.isFinite(&#x27;20&#x27;)); // falseconsole.log(Number.isFinite(20 / 0)); // falseconsole.log(Number.isInteger(20));// trueconsole.log(Number.isInteger(20.0));// true 1234567891011121314151617181920212223242526272829303132console.log(Math.sqrt(25)); // 5console.log(25 ** (1 / 2)); // 5console.log(8 ** (1 / 3)); // 2console.log(5 ** 2); // 25console.log(Math.max(1, 2, 3, 4, 5, 33, 6, 7)); //33console.log(Math.max(1, 2, 3, 4, 5, &#x27;33&#x27;, 6, 7)); //33console.log(Math.PI); // 3.141592653589793console.log(Math.random()); // Between 0 - 1console.log(Math.trunc(Math.random() * 6) + 1); // Between 1 - 6const randomInt = (max, min) =&gt; Math.trunc(Math.random() * (max - min) + 1) + min;console.log(Math.trunc(23.3)); // 23console.log(Math.round(23.3)); // 23console.log(Math.round(23.9)); // 24console.log(Math.ceil(23.3)); // 24console.log(Math.ceil(23.9)); // 24console.log(Math.floor(23.3)); // 23console.log(Math.floor(&#x27;23.9&#x27;)); // 23// Rounding decimalsconsole.log((2.7).toFixed(0)); // 3 (string)console.log((2.7).toFixed(3)); // 2.700 (string)console.log(+(2.7).toFixed(3)); // 2.7 Numeric Separators12345const diameter = 287_460_000_000;console.log(diameter); // 287460000000const price = 345_99;console.log(price);// 34599 BigInt12console.log(924363493238473294623946239747); // 9.243634932384733e+29console.log(924363493238473294623946239747n); // 924363493238473294623946239747n Operations123456const huge = 93222222244444444444444444321324n;const num = 3432;console.log(22384674238685674346n + 324739847n); // 22384674239010414193nconsole.log(huge * BigInt(num)); // 319938666742933333333333332910783968nconsole.log(huge * num);// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions 1console.log(11n / 3n); // 3n DatesCreating Dates12345678910111213//create a dateconst now = new Date();console.log(now); // Mon Jan 02 2023 15:20:12 GMT+0800 (中国标准时间)console.log(typeof now); // objectconsole.log(new Date(&#x27;Jan 02 2023 15:21:54&#x27;)); //Mon Jan 02 2023 15:21:54 GMT+0800 (中国标准时间)console.log(new Date(&#x27;December 24, 2015&#x27;)); // Thu Dec 24 2015 00:00:00 GMT+0800 (中国标准时间)console.log(new Date(2077, 12, 13, 2, 34, 89)); // Thu Jan 13 2078 02:35:29 GMT+0800 (中国标准时间)//month begins from 0;console.log(new Date(0)); // Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)console.log(new Date(3 * 24 * 60 * 60 * 1000)); // Sun Jan 04 1970 08:00:00 GMT+0800 (中国标准时间) Methods12345678910111213141516171819202122232425// Working with datesconst future = new Date(2077, 11, 13, 2, 34, 89);console.log(future); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)console.log(future.getFullYear()); // 2077console.log(future.getMonth()); // 11console.log(future.getDate()); // 13console.log(future.getHours()); // 2console.log(future.getMinutes()); // 35console.log(future.getSeconds()); // 29console.log(future.getMilliseconds()); // 0console.log(future.toISOString()); // 2077-12-12T18:35:29.000Zconst timeStamp = future.getTime();console.log(timeStamp); // 3406559729000console.log(new Date(timeStamp)); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)//TimeStamp of nowconsole.log(Date.now()); // 1672645408693//The day of this weekconsole.log(future.getDay()); // 1//Set version of these methodsfuture.setFullYear(2099);console.log(future.getFullYear()); // 2099"},{"title":"Nullish_Coalescing_Operater_and_Or_equal","path":"/wiki/JavaScript/Nullish_Coalescing_Operater_and_Or_equal.html","content":"??Nullish: null and undefined.(Not 0 or ‘ ‘),so it’ different from || 12const value = 0 ?? 10;console.log(value);//0 12const value = null ?? 10;console.log(value);//10 12const value = undefined ?? 10;console.log(value);//10 || =12a = a||ba ||= b ??=&amp;&amp;="},{"title":"Sets_and_Maps","path":"/wiki/JavaScript/Sets_and_Maps.html","content":"Sets and mapsIn ex6 ,two more data structures were finally introduced. Set is iterable SetsBasic usageUse new Set() to creat a new set. 12const set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);console.log(set);//Set(3) &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125; 12const set = new Set(&#x27;aniya&#x27;);console.log(set);//Set(4) &#123; &#x27;a&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;y&#x27; &#125; The input must be iterable. And the elements in a set is unique. And there is no order of the elements. No index. So there is no need to get a value form sets. Methods of set .size 12const set //4= new Set(&#x27;aniya&#x27;);console.log(set.size);//4 .has() 12const set = new Set(&#x27;aniya&#x27;);console.log(set.has(&#x27;a&#x27;), set.has(&#x27;0&#x27;));//true false To find out whether the set has the thing you want to know. .add() 1234const set = new Set();console.log(set);//Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set);//Set(1) &#123; &#x27;Tommy idiot&#x27; &#125; You can just add one at one time. .delete 123456const set = new Set();console.log(set); //Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set); //Set(1) &#123; &#x27;Tommy idiot&#x27; &#125;set.delete(&#x27;Tommy idiot&#x27;);console.log(set);//Set(0) &#123;&#125; .clear() 123const set = new Set(&#x27;aniya&#x27;);set.clear();console.log(set);//Set(0) &#123;&#125; To clear out the set. Loop over the set12345678const set = new Set(&#x27;aniya&#x27;);for (const item of set) &#123; console.log(item);&#125;//a//n//i//y Some usecases of sets To remove duplicated values of arrarys. 123const arr = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4];const arrUnique = [...new Set(arr)];console.log(arrUnique);//[ 1, 2, 3, 4 ] And we can konw its size by the size method. Maps Maps is alike to objects,data are also stored as key-value pairs. The biggest diffrence is that keys in maps can be any type,such as number, string ,object and even another map. While the keys in objects can only be string. Creat a map1234567891011const question = new Map([ [&#x27;key&#x27;, &#x27;value&#x27;], [&#x27;question&#x27;, &quot;What&#x27;s the best programming language in the world?&quot;], [1, &#x27;C&#x27;], [2, &#x27;Java&#x27;], [3, &#x27;Javascript&#x27;], [&#x27;correct&#x27;, 3], [true, &#x27;Congratulations! 🤣&#x27;], [false, &#x27;Try again!😅&#x27;],]);console.log(question); The argument is a big arrary which contains many small arrarys which are compose of key-value pairs. .set()1234567891011121314let o = &#123; name: &#x27;jonas&#x27;,&#125;;const map = new Map();map.set(1, &#x27;the first&#x27;);map.set(&#x27;key&#x27;, 2);map.set(o, o);console.log(map.set(o, o));console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; Calling the set method like this does not only update the map that’s called on,but it also returns the map. So you can just do that like this: 1234567map.set(1, &#x27;the first&#x27;).set(o, o).set(&#x27;key&#x27;, 2);console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; .get()1console.log(map.get(&#x27;key&#x27;));//2 .has().delete()If you want to use an “Complex datatype” as an key ,you should store it in an variation first. Wrong 123const map = new Map();map.set([1, 2], &#x27;this&#x27;);console.log(map.get([1, 2]));//undefined Because the two [1,2] is not the same object that is stored in heap. Right 1234const map = new Map();const arr = [1, 2];map.set(arr, &#x27;this&#x27;);console.log(map.get(arr)); //this Convert a object into a map.1newMap = new Map(Object.entries(objectName)); Loop over a map123for(const [key,value] of mapName)&#123;\tconsole.log(key,value);&#125;"},{"title":"Optional_Chaining","path":"/wiki/JavaScript/Optional_Chaining.html","content":"？Now if you want to know whether a restaurant’s opening hours in Monday 1console.log(restaurant.openingHours.mon); If mon is not exist, it will be undefined, not a big deal. But if openingHours is not exist ,it will be a error. So we can solve this problem with the ? 1console.log(restaurant.openingHours?.mon); We can also use it to use method. 1console.log(restaurant.order?.(0,1) ?? &#x27;Method does not exist.&#x27;)"},{"title":"Which_Data_Structure_to_Use","path":"/wiki/JavaScript/Which_Data_Structure_to_Use.html","content":"Which data structure to use?Sourece Of Data From the program itself From the UI From external sources For Simple List: Arrays or SetsArrays Use when you need ordered list of values (might contain duplicates) Use when you need to manipulate data Sets Use when you need to work with unique values Use when high-performance is really important Use to remove duplicates from arrays For Key/Value Pairs: Objects or MapsObjects Features More “traditional” key/value store(“abused” objects) Easier to write and access values with . and [ ] Use when you need to include functions(methods) working with JSON(can convert to map) Maps Features Better performance Keys can have any data type Easy to iterate Easy to compute size Use when you simply need to map key to values you need keys that are not strings"},{"title":"OOP","path":"/wiki/JavaScript/Object_Oriented_Programming.html","content":"Object-Oriented ProgrammingWhat is OOP? OOP is a programming paradigm based on the concept of objects We use objects to model(describe) real-world or abstract features Objects may contain data (properties) and code (methods). By using objects, we pack data and the corresponding behavior into one block. In OOP, objects are self-contained pieces/blocks of code Objects are building blocks of applications, and interact with one another Interactions happen through a public interface(API): methods that the code out side of the object can access and use to communicate with the object; Four Fundamental principles of OOP abstraction encapsulation inheritance polumorphism OOP In JS![93A0512868D930D5AD890F926DBB7C6D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\93A0512868D930D5AD890F926DBB7C6D.png) Prototypes123456789101112131415161718192021222324// Prototypesconsole.log(Person.prototype);Person.prototype.calcAge = function () &#123; console.log(2037 - this.birthYear);&#125;;jonas.calcAge();matilda.calcAge();console.log(jonas.__proto__);console.log(jonas.__proto__ === Person.prototype);console.log(Person.prototype.isPrototypeOf(jonas));console.log(Person.prototype.isPrototypeOf(matilda));console.log(Person.prototype.isPrototypeOf(Person));// .prototyeOfLinkedObjectsPerson.prototype.species = &#x27;Homo Sapiens&#x27;;console.log(jonas.species, matilda.species);console.log(jonas.hasOwnProperty(&#x27;firstName&#x27;));console.log(jonas.hasOwnProperty(&#x27;species&#x27;)); ![5E3F22E98E49E12A556E7822206F8C4D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\5E3F22E98E49E12A556E7822206F8C4D.png) ![BAEE3FFF41CE2088CBA7EC401A89B92A](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BAEE3FFF41CE2088CBA7EC401A89B92A.png) 12345678910111213141516171819202122// Prototypal Inheritance on Built-In Objectsconsole.log(jonas.__proto__);// Object.prototype (top of prototype chain)console.log(jonas.__proto__.__proto__);console.log(jonas.__proto__.__proto__.__proto__);console.dir(Person.prototype.constructor);const arr = [3, 6, 6, 5, 6, 9, 9]; // new Array === []console.log(arr.__proto__);console.log(arr.__proto__ === Array.prototype);console.log(arr.__proto__.__proto__);Array.prototype.unique = function () &#123; return [...new Set(this)];&#125;;console.log(arr.unique());const h1 = document.querySelector(&#x27;h1&#x27;);console.dir(x =&gt; x + 1); ES6 Classes Classes are NOT hoisted Classes are first-class citizens Classes are executed in strict mode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ES6 Classes// Class expression// const PersonCl = class &#123;&#125;// Class declarationclass PersonCl &#123; constructor(fullName, birthYear) &#123; this.fullName = fullName; this.birthYear = birthYear; &#125; // Instance methods // Methods will be added to .prototype property calcAge() &#123; console.log(2037 - this.birthYear); &#125; greet() &#123; console.log(`Hey $&#123;this.fullName&#125;`); &#125; get age() &#123; return 2037 - this.birthYear; &#125; // Set a property that already exists set fullName(name) &#123; if (name.includes(&#x27; &#x27;)) this._fullName = name; else alert(`$&#123;name&#125; is not a full name!`); &#125; get fullName() &#123; return this._fullName; &#125; // Static method static hey() &#123; console.log(&#x27;Hey there 👋&#x27;); console.log(this); &#125;&#125;const jessica = new PersonCl(&#x27;Jessica Davis&#x27;, 1996);console.log(jessica);jessica.calcAge();console.log(jessica.age);console.log(jessica.__proto__ === PersonCl.prototype); // true// PersonCl.prototype.greet = function () &#123;// console.log(`Hey $&#123;this.firstName&#125;`);// &#125;;jessica.greet(); Setters and GettersStatic Methods and Instance MethodsObject.create() 1234567891011121314151617181920212223// Object.createconst PersonProto = &#123; calcAge() &#123; console.log(2037 - this.birthYear); &#125;, init(firstName, birthYear) &#123; this.firstName = firstName; this.birthYear = birthYear; &#125;,&#125;;const steven = Object.create(PersonProto);console.log(steven);steven.name = &#x27;Steven&#x27;;steven.birthYear = 2002;steven.calcAge();console.log(steven.__proto__ === PersonProto); // trueconst sarah = Object.create(PersonProto);sarah.init(&#x27;Sarah&#x27;, 1979);sarah.calcAge(); Inheritance between Classes"},{"title":"String","path":"/wiki/JavaScript/Working_with_Strings.html","content":"Working With Stringsmethods Return new strings .length .indexOf() 123const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.indexOf(&#x27;Portugal&#x27;));//8console.log(airline.indexOf(&#x27;portugal&#x27;));//-1 ​ Case sensetive* .lastIndexOf() 12const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.lastIndexOf(&#x27;r&#x27;));//10 The last ‘r’. .slice() 1234const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.slice(4));//Air Portugalconsole.log(airline.slice(4, 7));//Airconsole.log(airline.slice(-2));//al It returns a new string. The end value is not included in the new string. When the argument is negative, it will count from the end. .toLowerCase() .toUpperCase() .trim() .replace() You can use regular expression here. 1console.log(airline.replaceAll(/A/g, &#x27;a&#x27;));//TaP air Portugal It replaced all ‘A’. .replaceAll() .repeat() 1234const planesInLine = function (n) &#123; console.log(`There are $&#123;n&#125; planes in line $&#123;&#x27;✈️&#x27;.repeat(n)&#125;`);&#125;;planesInLine(10);//There are 10 planes in line ✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️ Return booleans. .includes() .startsWith() endsWith() We do know that string is a type of primitives,why it has methods?Because javascript automaticlly will turn the string into an object,and when the operation is done, it will turn back into a string primitive. So all string methods return primitives, even if called on a string object. 12console.log(typeof new String(&#x27;aniya&#x27;)); //objectconsole.log(typeof new String(&#x27;aniya&#x27;).slice(-1));//string Other important method:split() join() split() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.split(&#x27;+&#x27;));//[ &#x27;qwer&#x27;, &#x27;zxcv&#x27;, &#x27;ajf0s&#x27;, &#x27;sjaf&#x27; ] join() ​ Input an array,return a string. 123const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;const strSplit = str.split(&#x27;+&#x27;);console.log(strSplit.join(&#x27;---&#x27;));//qwer---zxcv---ajf0s---sjaf Padding Methods padStart() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padStart(30, &#x27;)+&#x27;));//)+)+)+)+)+qwer+zxcv+ajf0s+sjaf padEnd() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padEnd(30, &#x27;)+&#x27;));//qwer+zxcv+ajf0s+sjaf)+)+)+)+)+"},{"title":"前言","path":"/wiki/JavaScript/index.html","content":"听JS教程留下的一部分笔记 为了拯救我那很烂的英语🙌，笔记主要是英文（自己后来也可能看不懂🤣🤣 上传的第一篇笔记😎😎😎"},{"title":"Spread_Operator","path":"/wiki/JavaScript/Spread_Operator.html","content":"Spread OperatorDeconstruct the values in the array, suitable for the comma separation (this applies to all iterables) Iterables:arrary, strings, maps, sets.Not objects Usually separated by commas: a function passes arguments, builds a new array 1234const arr = [7, 8, 9];const newArr = [1, 2, ...arr];console.log(newArr);//(5) [1, 2, 7, 8, 9]console.log(...newArr);//1 2 7 8 9 Application Shallow copy ``` jslet newArr = […oldArr];12345- Combine arrays - ``` js const Arr = [...Arr1,...Arr2]; 1console.log(...&quot;jonas&quot;);//j o n a s Specially Works for object, too. 1let newObj = &#123; ...oldObj,name:&quot;tom&quot;&#125; 以此来实现对象的浅拷贝 Rest PatternIt’s similar to the spread pattern, but the three dots are on the left. Example: 12const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);//1 2 (4) [3, 4, 5, 6] the Rest element must be the last one in []. Of course, object can use it too. In Function123456const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);const add = function (...numbers) &#123; console.log(numbers);&#125;;add(1, 2, 3, 45, 6, 56, 45, 755, 3, 57);//(10) [1, 2, 3, 45, 6, 56, 45, 755, 3, 57]"}]