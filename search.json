[{"title":"GPG简要入门指南","path":"/2023/02/23/gpg/","content":"什么是GPG？ GPG 是一个加密、解密、签名、验证工具。 加密：对信息进行加密，有对称加密和非对称加密 解密：对加密的信息解密 签名：对发出的信息签名，使他人能验证信息为本人发出，且未被篡改过 验证：对接收到的签名的信息进行验证 GPG 还是一个密钥管理工具 管理自己的私钥，其他人的公钥，以及提供了一套公钥信任体系。安装下载安装 GPG：访问 GPG官网，下载适合自己操作系统平台的安装程序。安装完成后，打开 CMD 窗口，输入 gpg --version验证是否安装成功出现下列信息表示成功123456789101112131415C:\\Users ame&gt;gpg --versiongpg (GnuPG) 2.4.0libgcrypt 1.10.1Copyright (C) 2021 g10 Code GmbHLicense GNU GPL-3.0-or-later &lt;https://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Home: C:\\Users ame\\AppData\\Roaming\\gnupgSupported algorithms:Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSACipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224Compression: Uncompressed, ZIP, ZLIB, BZIP2 开始使用输入gpg -help列出所有指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Commands: -s, --sign make a signature --clear-sign make a clear text signature -b, --detach-sign make a detached signature -e, --encrypt encrypt data -c, --symmetric encryption only with symmetric cipher -d, --decrypt decrypt data (default) --verify verify a signature -k, --list-keys list keys --list-signatures list keys and signatures --check-signatures list and check key signatures --fingerprint list keys and fingerprints -K, --list-secret-keys list secret keys --generate-key generate a new key pair --quick-generate-key quickly generate a new key pair --quick-add-uid quickly add a new user-id --quick-revoke-uid quickly revoke a user-id --quick-set-expire quickly set a new expiration date --full-generate-key full featured key pair generation --generate-revocation generate a revocation certificate --delete-keys remove keys from the public keyring --delete-secret-keys remove keys from the secret keyring --quick-sign-key quickly sign a key --quick-lsign-key quickly sign a key locally --quick-revoke-sig quickly revoke a key signature --sign-key sign a key --lsign-key sign a key locally --edit-key sign or edit a key --change-passphrase change a passphrase --export export keys --send-keys export keys to a keyserver --receive-keys import keys from a keyserver --search-keys search for keys on a keyserver --refresh-keys update all keys from a keyserver --import import/merge keys --card-status print the card status --edit-card change data on a card --change-pin change a card&#x27;s PIN --update-trustdb update the trust database --print-md print message digests --server run in server mode --tofu-policy VALUE set the TOFU policy for a keyOptions controlling the diagnostic output: -v, --verbose verbose -q, --quiet be somewhat more quiet --options FILE read options from FILE --log-file FILE write server mode logs to FILEOptions controlling the configuration: --default-key NAME use NAME as default secret key --encrypt-to NAME encrypt to user ID NAME as well --group SPEC set up email aliases --openpgp use strict OpenPGP behavior -n, --dry-run do not make any changes -i, --interactive prompt before overwritingOptions controlling the output: -a, --armor create ascii armored output -o, --output FILE write output to FILE --textmode use canonical text mode -z N set compress level to N (0 disables)Options controlling key import and export: --auto-key-locate MECHANISMS use MECHANISMS to locate keys by mail address --auto-key-import import missing key from a signature --include-key-block include the public key in signatures --disable-dirmngr disable all access to the dirmngrOptions to specify keys: -r, --recipient USER-ID encrypt for USER-ID -u, --local-user USER-ID use USER-ID to sign or decrypt(See the man page for a complete listing of all commands and options)Examples: -se -r Bob [file] sign and encrypt for user Bob --clear-sign [file] make a clear text signature --detach-sign [file] make a detached signature --list-keys [names] show keys --fingerprint [names] show fingerprintsPlease report bugs to &lt;https://bugs.gnupg.org&gt;. 生成密匙输入gpg --gen-key生成依据提示输入名称、电子邮箱等信息后输出密匙的相关信息1234567891011121314151617181920212223242526Note: Use &quot;gpg --full-generate-key&quot; for a full featured key generation dialog.GnuPG needs to construct a user ID to identify your key.Real name: xxxxEmail address: xxxxYou selected this USER-ID: &quot;xxxx &lt;xxxx@qq.com&gt;&quot;Change (N)ame, (E)mail, or (O)kay/(Q)uit? oWe need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.We need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.gpg: directory &#x27;C:\\\\Users\\ ame\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d&#x27; createdgpg: revocation certificate stored as &#x27;C:\\\\Users\\ ame\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d\\\\064E4BB07566BA558B6B006A4BF6180BAB71781D.rev&#x27;public and secret key created and signed.pub ed25519 2023-02-23 [SC] [expires: 2025-02-22] 064E4BB07566BA558B6B006A4BF6180BAB71781Duid xxxx &lt;xxxx@qq.com&gt;sub cv25519 2023-02-23 [E] [expires: 2025-02-22] 其中064E4BB07566BA558B6B006A4BF6180BAB71781D这是”用户ID”的Hash字符串，可以用来替代”用户ID”。查看密匙列表输入gpg --list-keys如果你要从密钥列表中删除某个密钥，可以使用delete-key参数。1gpg --delete-key [用户ID] 加密和解密这个过程是对文件进行的 加密：```1gpg --recipient [用户ID] --output [加密文件输出路径] --encrypt [加密文件输入路径] 解密：1gpg [加密文件路径] 签名有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。 1gpg --sign test.txt 然后生成了一个test.txt.gpg文件，我们打开这个文件后，发现这也是一个二进制的数据，这并不是加密后的数据，与上边的二进制数据不一样。如果想生成ASCII码的签名文件，可以使用clearsign参数 1gpg --clearsign test.txt 如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。 1gpg --detach-sign test.txt 是一个二进制的数据，如果想采用ASCII码形式，要加上armor参数 1gpg --armor --detach-sign test.txt 验证签名我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证 1gpg --verify test.txt.asc test.txt","tags":["tools"]},{"title":"高阶函数、声明式和命令式编程","path":"/2023/01/20/高阶函数、声明式和命令式编程/","content":"高阶函数、命令式编程和声明式编程什么是高阶函数？ 以函数作为参数 以函数作为返回值 常用于函数装饰器 12345let HOFO = function (fn) &#123; return function (...args) &#123; return fn.apply(this, args); &#125;;&#125;; 高阶函数的好处 高阶函数的魅力在于它的可重复利用性，如果不是高阶函数，map、filter、reduce 等强大的数组函数就不可能存在。 使 JavaScript 适合函数式编程的原因是它接受高阶函数。 常用高阶函数示例防抖和节流节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 once 让函数只执行一次，常用于节流 ```jslet once = function (fn) { return function (…args) { if (fn) &#123; setTimeout(() =&gt; &#123; fn = null; &#125;); return fn.apply(this, args); &#125; };}; 1234567891011121314151617- throttle - 让函数在执行后的一段时间不能被再次触发 - ```js let throttle = function (fn, time = 500) &#123; let timer; return function (...args) &#123; if (timer == null) &#123; fn.apply(this, args); timer = setTimeout(() =&gt; &#123; timer = null; &#125;, time); &#125; &#125;; &#125;; consumer 将多次触发的任务加入任务队列，依次间隔执行 ```jsfunction consumer(fn, time){ let tasks = [], timer; return function(…args){ tasks.push(fn.bind(this, ...args)); if(timer == null)&#123; timer = setInterval(() =&gt; &#123; tasks.shift().call(this) if(tasks.length &lt;= 0)&#123; clearInterval(timer); timer = null; &#125; &#125;, time) &#125; }} 123456789101112131415#### 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时- debounce - ```js let debounce = function (fn, time) &#123; let timer; return function (...args) &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; return fn.apply(this, args); &#125;, time); &#125;; &#125;; 非纯函数和纯函数(pure function)什么是纯函数和非纯函数 纯函数是指在给定输入的参数下，输出总是确定的，不依赖于外界环境 例如： 12let add = (a, b) =&gt; a + b;//add返回的值只与输入参数有关 非纯函数依赖上下文 例如： 123let count = 0;let add = () =&gt; count++;//add返回的值依赖于count的值 如果代码中非纯函数过多，代码会变得难以维护，所以我们要减少写出非纯函数 将非纯函数转化为纯函数123456789101112131415const isIterable = obj =&gt; obj != null &amp;&amp; typeof obj[Symbol.iterator] === &#x27;function&#x27;;function iterative(fn) &#123; return function(subject, ...rest) &#123; if(isIterable(subject)) &#123; const ret = []; for(let obj of subject) &#123; ret.push(fn.apply(this, [obj, ...rest])); &#125; return ret; &#125; return fn.apply(this, [subject, ...rest]); &#125;&#125; 这里的iterative和isIterable都是纯函数，它们能方便地对可迭代对象批量执行函数 例如假如现在有一个setColor函数能改变元素的颜色，如果这时我们要对元素批量执行，再定义一个setColors的话就产生了两个非纯函数，而如果我们利用上面的iterative函数就可以直接将setColor函数传入其中，实现批量操作，减少了非纯函数的产生。 命令式和声明式编程以改变一个按钮的状态为例 命令式编程关注怎么做 ```jsswitcher.onclick = function(evt){ if(evt.target.className === ‘on’){evt.target.className = &#39;off&#39;; }else{evt.target.className = &#39;on&#39;; }}12345678910111213141516- 声明式编程关注做什么 - ```js function toggle(...actions)&#123; return function(...args)&#123; let action = actions.shift(); actions.push(action); return action.apply(this, args); &#125; &#125; switcher.onclick = toggle( evt =&gt; evt.target.className = &#x27;off&#x27;, evt =&gt; evt.target.className = &#x27;on&#x27; ); 看起来区别不大但当这个按钮有三种状态时，在命令式编程下我们需要重写if-else的逻辑，而声明式编程下我们只需要在toggle里再多传入evt =&gt; evt.target.className = &#39;warn&#39;就可以实现。","tags":["JS","青训营"]},{"title":"组件化封装","path":"/2023/01/18/组件化封装/","content":"JS组件封装 基本方法（以轮播图组件为例） 结构设计12345678910111213141516&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;slider-list__item--selected&quot;&gt; &lt;img src=&quot;xx.png&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot; &quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 展现效果 行为设计 API(功能) Event(控制流)123456789101112131415161718192021222324252627282930313233343536class Slider&#123; constructor(id)&#123; this.container = document.getElementById(id); this.items = this.container .querySelectorAll(&#x27;.slider-list__item, .slider-list__item--selected&#x27;); &#125; getSelectedItem()&#123; const selected = this.container .querySelector(&#x27;.slider-list__item--selected&#x27;); return selected &#125; getSelectedItemIndex()&#123; return Array.from(this.items).indexOf(this.getSelectedItem()); &#125; slideTo(idx)&#123; const selected = this.getSelectedItem(); if(selected)&#123; selected.className = &#x27;slider-list__item&#x27;; &#125; const item = this.items[idx]; if(item)&#123; item.className = &#x27;slider-list__item--selected&#x27;; &#125; &#125; slideNext()&#123; const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); &#125; slidePrevious()&#123; const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); &#125;&#125; 但是这样功能虽然实现，但是 可扩展性差，例如假如要加导航栏，既要改js，还要对应加上html和css 可复用性差，多次使用该组件需要多次复制相同的代码 如何改进？ 重构插件化解耦 将控制元素抽取成插件123registerPlugins(...plugins)&#123;//abstract &#125;; 插件与组件通过依赖注入方式建立联系123456789const pluginController = &#123;//abstract action(slider)&#123;//abstraction &#125;&#125;const pluginPrevious = &#123;//abstract&#125; 通过把组件的组成部分抽象成插件，我们只要在使用该组件时传入要注册的插件，就可以方便的实现组件的增删，并且后来如果还要编写新的插件也可以按原逻辑在原有js上增加。模板化 将HTML模板化。更易于扩展在插件的render方法中把组件的html模板化，123render()&#123; return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`;&#125;, 此时，组件的html代码只有短短一行1&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt;&lt;/div&gt; 抽象化(组件框架) 将组件通用模型抽象出来1234567891011121314class Component &#123; constructor(id, opts = &#123; name, data: [] &#125;) &#123; this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); &#125; registerPlugins(...plugins) &#123;//abstract &#125;; render(data) &#123;//abstract return &quot;&quot;; &#125;&#125; 这里把通用的组件模型抽象为一个Component类，后来增添新组件可通过extend关键字来继承这个component。 总结 组件设计的原则：封装性、正确性、复用性、扩展性 实现组件的步骤：结构设计、展现效果、行为设计 三次重构 插件化 模板化 抽象化","tags":["JS","青训营"]},{"title":"Advanced_Dom","path":"/wiki/JavaScript/Advanced_Dom.html","content":"Advanced DomHow the Dom really works?![BB93EF78E760EDFA026A6E09647E68DA](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BB93EF78E760EDFA026A6E09647E68DA.png) Selecting, Creating, and Deleting ElementsSelect1234567const queryAllButtons = document.querySelectorAll(&#x27;button&#x27;);console.log(queryAllButtons); // NodeList(9)// It is fixedconst getAllButtons = document.getElementsByTagName(&#x27;button&#x27;);console.log(getAllButtons); // HTMLCollection(9)// It updates itself as the html changes. Create12345678910111213const header = document.querySelector(&#x27;.header&#x27;);const message = document.createElement(&#x27;div&#x27;);message.classList.add(&#x27;cookie-message&#x27;);message.textContent = &#x27;We use cookied for improved functionality and analytics.&#x27;;message.innerHTML = &#x27;We use cookied for improved functionality and analytics.&lt;button class=&quot;btn btn--close-cookie&quot;&gt;Got it!&lt;/button&gt;&#x27;;header.prepend(message);header.append(message);header.after(message);header.before(message);message.remove(); Styles, Attributes and ClassesStyles123message.style.width = &#x27;120%&#x27;;console.log(message.style.width); // 120%console.log(message.style.height); // nothing Only works for the inline style. 12console.log(getComputedStyle(message)); // CSSStyleDeclarationconsole.log(getComputedStyle(message).height); // 50.6px Change the css variables 1document.documentElement.style.setProperty(&#x27;--color-primary&#x27;, &#x27;red&#x27;) Attributes12345678const logo = document.querySelector(&#x27;.nav__logo&#x27;);console.log(logo.alt); // Bankist logoconsole.log(logo.src); // http://127.0.0.1:5501/complete-javascript-course/13-Advanced-DOM-Bankist/starter/img/logo.pngconsole.log(logo.getAttribute(&#x27;src&#x27;)); // img/logo.pngconsole.log(logo.className); // nav__logologo.setAttribute(&#x27;designer&#x27;, &#x27;jonas&#x27;);console.log(logo.getAttribute(&#x27;designer&#x27;)); // jonas Data attributes 1logo.dataset Classes1234logo.classList.add(&#x27;c&#x27;);logo.classList.remove(&#x27;c&#x27;);logo.classList.toggle(&#x27;c&#x27;);logo.classList.contains(&#x27;c&#x27;); Implementing Smooth ScrollingOld school way1234567891011const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; const s1croods = section1.getBoundingClientRect(); window.scrollTo(&#123; left: s1croods.left + window.pageXOffset, top: s1croods.top + window.pageYOffset, behavior: &#x27;smooth&#x27;, &#125;);&#125;); Modern way123456const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; section1.scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;);&#125;); Type of Events and Event Handlers1234567891011121314const h1 = document.querySelector(&#x27;h1&#x27;);const alert = e =&gt; &#123; console.log(&#x27;Enter&#x27;); h1.removeEventListener(&#x27;mouseenter&#x27;, alert);&#125;;h1.addEventListener(&#x27;mouseenter&#x27;, alert);h1.addEventListener(&#x27;mouseleave&#x27;, e =&gt; &#123; console.log(&#x27;Leave&#x27;);&#125;);window.addEventListener(&#x27;keydown&#x27;, e =&gt; &#123; console.log(e);&#125;); Event Propagation_ Bubbling and CapturingEvent DelegationDom Traversing12345678910111213141516171819const h1 = document.querySelector(&#x27;h1&#x27;);//Going downwards: childconsole.log(h1.querySelectorAll(&#x27;.highlight&#x27;));console.log(h1.childNodes); // NodeList(9)console.log(h1.children); // HTMLCollection(3)h1.firstElementChild.style.color = &#x27;white&#x27;;h1.lastElementChild.style.color = &#x27;white&#x27;;// Going upwards: parentsconsole.log(h1.parentNode);console.log(h1.parentElement);h1.closest(&#x27;.header&#x27;).style.background = &#x27;var(--gradient-secondary)&#x27;;// Going sideways: siblingsconsole.log(h1.previousElementSibling);console.log(h1.nextElementSibling);console.log(h1.parentElement.children); The Intersection Observer API。。。。"},{"title":"Array","path":"/wiki/JavaScript/Array.html","content":"ArraySimple Array Methods slice() It does not change the original array. splice() It changes the original array. 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr.splice(2)); //(3) [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]console.log(arr); //(2) [&#x27;a&#x27;, &#x27;b&#x27;] reverse() Change！ concat() 1let arr = arr1.concat(arr2); join() at()Similar to [] 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[0]); //aconsole.log(arr.at(0)); //a But at() can use negative index. So if we want the last element of an array. 1234let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[arr.length - 1]); //econsole.log(arr.slice(-1)[0]); //econsole.log(arr.at(-1)); //e And when you use method chaining. forEach()You can not break or continue it. We can also use it in Maps and Sets map()Map returns a new array containing the results of applying an operation on all original array elements filter()filter returns a new array containing the array elements that passed a specified test condition reduce()reduce boils (‘reduces’) all array elements down to one single value(e.g. adding all elements together 1234const maxMov = movements.reduce( (acc, mov) =&gt; (acc &lt; mov ? mov : acc), movements[0]); find()findIndex()includes()some()123console.log(movements.some(mov =&gt; mov &gt; 0));//trueconst deposit = mov =&gt; mov &gt; 0;console.log(movements.some(deposit)); //true every()Similar to some(), but need all elements satisfy the condition flat()12let arr = [[1, 2, 3], 4, 5, [6, [7, 8]]];console.log(arr.flat().flat());//(8) [1, 2, 3, 4, 5, 6, 7, 8] flatMap()Similar to map(), but flat its result. sort()Change the original array. 12345let movements = [200, 450, -400, 3000, -650, -130, 70, 1300];//return &lt; 0 , A, B//return &gt; 0 , B, Amovements.sort((a, b) =&gt; a - b);console.log(movements);//(8) [-650, -400, -130, 70, 200, 450, 1300, 3000] new Array()fill()1234const x = new Array(7);console.log(x);//(7) [空 ã7]x.fill(1, 3);console.log(x);//[空 ã3, 1, 1, 1, 1] Array.from()12const x = Array.from(&#123; length: 7 &#125;, () =&gt; 1);console.log(x);//(7) [1, 1, 1, 1, 1, 1, 1] 12const x = Array.from(&#123; length: 7 &#125;, (cur, i) =&gt; i + 1);console.log(x); //(7) [1, 2, 3, 4, 5, 6, 7] Turn NodeList into an Array. 12const movementsUI = Array.from(document.querySelectorAll(&#x27;.movements__value&#x27;));console.log(movementsUI);//(8) [div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value] Which Array Method to Use?To Mutate Original Array Add to original push() (end) unshift() (start) Remove from original pop() (end) shift() (start) splice() (any) Others reverse() sort() fill() A New Array Computed from original map() Filtered using condition filter() Portion of original slice() Adding original to other concat() Flattening the original flat() flatMap() An Array index Based on value includes() Based on test condition findIndex() An Array Element Based on test condition find() Konw if array includes Based on value includes() Based on test condition some() every() A New String Based on separator string join() To Transform to Value Based on accumulater reduce() To Just Loop Array Based on callback: foreach()"},{"title":"Complie_and_Interpret","path":"/wiki/JavaScript/Complie_and_Interpret.html","content":"Complilation先编译（compile）再执行（execute） Interpretation逐行编译，一边执行 Just-in-time(JIT) complilation现代javascript混合使用编译和解释,称为即时编译。"},{"title":"Function","path":"/wiki/JavaScript/Functions.html","content":"FunctionsDefault ParametersWhy We Need It? If not 123456789101112const bookings = [];const createBooking = function (flightNum, numPassengers, price) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: undefined, price: undefined&#125; If you have 12345678910111213141516const bookings = [];const createBooking = function ( flightNum, numPassengers = 1, price = 199 * numPassengers) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 199&#125; If you want to skip some parameters, you can set it as undefined 12createBooking(&#x27;LH123&#x27;, undefined, 1000);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 1000&#125; How Passing Arguments Works:Value vs. ReferenceJavascript can only pass by value, no passing by reference. First-Class vs. Higher-ordered FunctionsFirst-Class Functions JavaScript treats functions as first-class citizens This means that functions are simply values Functions are just another “type” of object So we can: Store functions in variables or properties Passing functions as arguments to other functions Return functions from functions Call methods on functions Higher-Ordered FunctionsWhat is it? A function that receives another function as an argument ,that returns a new function, or both This is only possible because of first-class functions Why we need it a higher level of abstruction Functions Accepting Callback Functions123456789101112131415161718192021222324252627// Functions Accepting Callback Functionsconst oneWord = function (str) &#123; return str.replace(/ /g, &#x27;&#x27;).toLowerCase();&#125;;const upperFirstWord = function (str) &#123; const [first, ...others] = str.split(&#x27; &#x27;); return [first.toUpperCase(), ...others].join(&#x27; &#x27;);&#125;;// Higher-order functionconst transformer = function (str, fn) &#123; console.log(`Original string: $&#123;str&#125;`); console.log(`Transformed string: $&#123;fn(str)&#125;`); console.log(`Transformed by: $&#123;fn.name&#125;`);&#125;;transformer(&#x27;JavaScript is the best!&#x27;, upperFirstWord);transformer(&#x27;JavaScript is the best!&#x27;, oneWord);// JS uses callbacks all the timeconst high5 = function () &#123; console.log(&#x27;👋&#x27;);&#125;;document.body.addEventListener(&#x27;click&#x27;, high5);[&#x27;Jonas&#x27;, &#x27;Martha&#x27;, &#x27;Adam&#x27;].forEach(high5); Functions Ruturning functions12345678const greet = function (greeting) &#123; return function (name) &#123; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`); &#125;;&#125;;const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;);//Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;);//Hi, Aniya If you use the arrow function 1234const greet = greeting =&gt; name =&gt; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`);const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;); //Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;); //Hi, Aniya Call()123456789101112131415161718192021const lufthansa = &#123; airline: &#x27;Lufthansa&#x27;, iataCode: &#x27;LH&#x27;, bookings: [], book(flightNum, name) &#123; console.log( `$&#123;name&#125; booked a seat on $&#123;this.airline&#125; flight $&#123;this.iataCode&#125;$&#123;flightNum&#125;` ); this.bookings.push(&#123; flight: `$&#123;this.iataCode&#125;$&#123;flightNum&#125;`, name &#125;); &#125;,&#125;;lufthansa.book(239, &#x27;Aniya&#x27;);const eurowings = &#123; airline: &#x27;eurowings&#x27;, name: &#x27;Eurowings&#x27;, iataCode: &#x27;EW&#x27;, bookings: [],&#125;;const book = lufthansa.book;book.call(eurowings, 23, &#x27;hai&#x27;); The first argument is the object that you want the this point to.The rest argument is the rest argument that the original the function need. apply()1book.apply(eurowings, [234, &#x27;ajdfhha&#x27;]); Difference: The second argument is an array,to accept origin arguments. Same as 1book.call(eurowings,...[234, &#x27;ajdfhha&#x27;]); bind()It will return a functions in which the this is the argument you passed in. 123book.bind(eurowings)(224, &#x27;asjf&#x27;);const bookEu = book.bind(eurowings);bookEu(2323, &#x27;asjfa&#x27;); Also, you can use it just like the call()method, passing in more arguments. If you don’t want to set this, just use null. Partial applicationwe can preset some arguments Immediately Invoked Function Expressions(IIFE)123(function () &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); Or 123(() =&gt; &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); You can not call it tiwice. Data Encapsulation and Data PrivacyClosuers A function always has access to the variable enviroment(VE) of the execution context in which it was created,even after that execution context was gone. Closure has priority over the scope chain. A closure gives a function access to all the variables of its parent function, even after that parent function has returned.The function keeps a reference to its outer scope, which preserves the scope chain all the time. Examples: let f; const g = function () &#123; const a = 1; f = function () &#123; console.log(a * 3); &#125;; &#125;; g(); f();//3 setTimeout()"},{"title":"Nullish_Coalescing_Operater_and_Or_equal","path":"/wiki/JavaScript/Nullish_Coalescing_Operater_and_Or_equal.html","content":"??Nullish: null and undefined.(Not 0 or ‘ ‘),so it’ different from || 12const value = 0 ?? 10;console.log(value);//0 12const value = null ?? 10;console.log(value);//10 12const value = undefined ?? 10;console.log(value);//10 || =12a = a||ba ||= b ??=&amp;&amp;="},{"title":"LOOP","path":"/wiki/JavaScript/Loop.html","content":"for-of and for-in1234567891011for (const item of restaurant.starterMenu) console.log(item);//Focaccia//Bruschetta//Garlic Bread//Caprese Saladfor (const index in restaurant.starterMenu) console.log(index);//0//1//2//3//4 Item is always the current element in each iteration. Index is always the current index or property name in each iteration. You can also use if-else to break or continue the loop. Acess the item and index at the same time1234567891011for (const item of restaurant.starterMenu.entries()) console.log(item);//(2) [0, &#x27;Focaccia&#x27;]//(2) [1, &#x27;Bruschetta&#x27;]//(2) [2, &#x27;Garlic Bread&#x27;]//(2) [3, &#x27;Caprese Salad&#x27;]for (const index in restaurant.starterMenu) console.log(restaurant.starterMenu[index], index);//Focaccia 0//Bruschetta 1//Garlic Bread 2//Caprese Salad 3 So you can see we used entries()method in for-of loop entries() An Array Iterator 12console.log(...restaurant.starterMenu.entries());//(2) [0, &#x27;Focaccia&#x27;] (2) [1, &#x27;Bruschetta&#x27;] (2) [2, &#x27;Garlic Bread&#x27;] (2) [3, &#x27;Caprese Salad&#x27;] Object.entries(objectName) 12console.log(Object.entries(restaurant));//(6) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2)] Each Array is composed of the key and the value. If you want to loop a objectObject.keys(objectName)This method returns an Arrary composed by the object’s property names. 12console.log(Object.keys(restaurant));//(6) [&#x27;name&#x27;, &#x27;location&#x27;, &#x27;categories&#x27;, &#x27;starterMenu&#x27;, &#x27;mainMenu&#x27;, &#x27;openingHours&#x27;] Object.values(objectName)This method returns an Arrary composed by the object’s property values. 12console.log(Object.values(restaurant));//(6) [&#x27;Classico Italiano&#x27;, &#x27;Via Angelo Tavanti 23, Firenze, Italy&#x27;, Array(4), Array(4), Array(3), &#123;…&#125;]"},{"title":"Numbers_and_Dates","path":"/wiki/JavaScript/Numbers_and_Dates.html","content":"Numbers and DatesNumbers12345678910111213141516171819202122232425262728// Number// Binary base 2 - 0 1console.log(23 === 23.0); //trueconsole.log(0.1 + 0.2); //0.30000000000000004// Conversionconsole.log(Number(&#x27;23&#x27;));console.log(+&#x27;23&#x27;);// Parsingconsole.log(Number.parseInt(&#x27;30px&#x27;, 10)); //30console.log(Number.parseInt(&#x27;e23&#x27;, 10)); //NaNconsole.log(Number.parseFloat(&#x27; 2.5rem&#x27;, 10)); //2.5// Check if value is NaNconsole.log(Number.isNaN(20)); //falseconsole.log(Number.isNaN(&#x27;20&#x27;)); //falseconsole.log(Number.isNaN(+&#x27;20d&#x27;)); //trueconsole.log(Number.isNaN(20 / 0)); //false// Check if value is numberconsole.log(Number.isFinite(20)); // trueconsole.log(Number.isFinite(&#x27;20&#x27;)); // falseconsole.log(Number.isFinite(20 / 0)); // falseconsole.log(Number.isInteger(20));// trueconsole.log(Number.isInteger(20.0));// true 1234567891011121314151617181920212223242526272829303132console.log(Math.sqrt(25)); // 5console.log(25 ** (1 / 2)); // 5console.log(8 ** (1 / 3)); // 2console.log(5 ** 2); // 25console.log(Math.max(1, 2, 3, 4, 5, 33, 6, 7)); //33console.log(Math.max(1, 2, 3, 4, 5, &#x27;33&#x27;, 6, 7)); //33console.log(Math.PI); // 3.141592653589793console.log(Math.random()); // Between 0 - 1console.log(Math.trunc(Math.random() * 6) + 1); // Between 1 - 6const randomInt = (max, min) =&gt; Math.trunc(Math.random() * (max - min) + 1) + min;console.log(Math.trunc(23.3)); // 23console.log(Math.round(23.3)); // 23console.log(Math.round(23.9)); // 24console.log(Math.ceil(23.3)); // 24console.log(Math.ceil(23.9)); // 24console.log(Math.floor(23.3)); // 23console.log(Math.floor(&#x27;23.9&#x27;)); // 23// Rounding decimalsconsole.log((2.7).toFixed(0)); // 3 (string)console.log((2.7).toFixed(3)); // 2.700 (string)console.log(+(2.7).toFixed(3)); // 2.7 Numeric Separators12345const diameter = 287_460_000_000;console.log(diameter); // 287460000000const price = 345_99;console.log(price);// 34599 BigInt12console.log(924363493238473294623946239747); // 9.243634932384733e+29console.log(924363493238473294623946239747n); // 924363493238473294623946239747n Operations123456const huge = 93222222244444444444444444321324n;const num = 3432;console.log(22384674238685674346n + 324739847n); // 22384674239010414193nconsole.log(huge * BigInt(num)); // 319938666742933333333333332910783968nconsole.log(huge * num);// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions 1console.log(11n / 3n); // 3n DatesCreating Dates12345678910111213//create a dateconst now = new Date();console.log(now); // Mon Jan 02 2023 15:20:12 GMT+0800 (中国标准时间)console.log(typeof now); // objectconsole.log(new Date(&#x27;Jan 02 2023 15:21:54&#x27;)); //Mon Jan 02 2023 15:21:54 GMT+0800 (中国标准时间)console.log(new Date(&#x27;December 24, 2015&#x27;)); // Thu Dec 24 2015 00:00:00 GMT+0800 (中国标准时间)console.log(new Date(2077, 12, 13, 2, 34, 89)); // Thu Jan 13 2078 02:35:29 GMT+0800 (中国标准时间)//month begins from 0;console.log(new Date(0)); // Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)console.log(new Date(3 * 24 * 60 * 60 * 1000)); // Sun Jan 04 1970 08:00:00 GMT+0800 (中国标准时间) Methods12345678910111213141516171819202122232425// Working with datesconst future = new Date(2077, 11, 13, 2, 34, 89);console.log(future); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)console.log(future.getFullYear()); // 2077console.log(future.getMonth()); // 11console.log(future.getDate()); // 13console.log(future.getHours()); // 2console.log(future.getMinutes()); // 35console.log(future.getSeconds()); // 29console.log(future.getMilliseconds()); // 0console.log(future.toISOString()); // 2077-12-12T18:35:29.000Zconst timeStamp = future.getTime();console.log(timeStamp); // 3406559729000console.log(new Date(timeStamp)); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)//TimeStamp of nowconsole.log(Date.now()); // 1672645408693//The day of this weekconsole.log(future.getDay()); // 1//Set version of these methodsfuture.setFullYear(2099);console.log(future.getFullYear()); // 2099"},{"title":"OOP","path":"/wiki/JavaScript/Object_Oriented_Programming.html","content":"Object-Oriented ProgrammingWhat is OOP? OOP is a programming paradigm based on the concept of objects We use objects to model(describe) real-world or abstract features Objects may contain data (properties) and code (methods). By using objects, we pack data and the corresponding behavior into one block. In OOP, objects are self-contained pieces/blocks of code Objects are building blocks of applications, and interact with one another Interactions happen through a public interface(API): methods that the code out side of the object can access and use to communicate with the object; Four Fundamental principles of OOP abstraction encapsulation inheritance polumorphism OOP In JS![93A0512868D930D5AD890F926DBB7C6D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\93A0512868D930D5AD890F926DBB7C6D.png) Prototypes123456789101112131415161718192021222324// Prototypesconsole.log(Person.prototype);Person.prototype.calcAge = function () &#123; console.log(2037 - this.birthYear);&#125;;jonas.calcAge();matilda.calcAge();console.log(jonas.__proto__);console.log(jonas.__proto__ === Person.prototype);console.log(Person.prototype.isPrototypeOf(jonas));console.log(Person.prototype.isPrototypeOf(matilda));console.log(Person.prototype.isPrototypeOf(Person));// .prototyeOfLinkedObjectsPerson.prototype.species = &#x27;Homo Sapiens&#x27;;console.log(jonas.species, matilda.species);console.log(jonas.hasOwnProperty(&#x27;firstName&#x27;));console.log(jonas.hasOwnProperty(&#x27;species&#x27;)); ![5E3F22E98E49E12A556E7822206F8C4D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\5E3F22E98E49E12A556E7822206F8C4D.png) ![BAEE3FFF41CE2088CBA7EC401A89B92A](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BAEE3FFF41CE2088CBA7EC401A89B92A.png) 12345678910111213141516171819202122// Prototypal Inheritance on Built-In Objectsconsole.log(jonas.__proto__);// Object.prototype (top of prototype chain)console.log(jonas.__proto__.__proto__);console.log(jonas.__proto__.__proto__.__proto__);console.dir(Person.prototype.constructor);const arr = [3, 6, 6, 5, 6, 9, 9]; // new Array === []console.log(arr.__proto__);console.log(arr.__proto__ === Array.prototype);console.log(arr.__proto__.__proto__);Array.prototype.unique = function () &#123; return [...new Set(this)];&#125;;console.log(arr.unique());const h1 = document.querySelector(&#x27;h1&#x27;);console.dir(x =&gt; x + 1); ES6 Classes Classes are NOT hoisted Classes are first-class citizens Classes are executed in strict mode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ES6 Classes// Class expression// const PersonCl = class &#123;&#125;// Class declarationclass PersonCl &#123; constructor(fullName, birthYear) &#123; this.fullName = fullName; this.birthYear = birthYear; &#125; // Instance methods // Methods will be added to .prototype property calcAge() &#123; console.log(2037 - this.birthYear); &#125; greet() &#123; console.log(`Hey $&#123;this.fullName&#125;`); &#125; get age() &#123; return 2037 - this.birthYear; &#125; // Set a property that already exists set fullName(name) &#123; if (name.includes(&#x27; &#x27;)) this._fullName = name; else alert(`$&#123;name&#125; is not a full name!`); &#125; get fullName() &#123; return this._fullName; &#125; // Static method static hey() &#123; console.log(&#x27;Hey there 👋&#x27;); console.log(this); &#125;&#125;const jessica = new PersonCl(&#x27;Jessica Davis&#x27;, 1996);console.log(jessica);jessica.calcAge();console.log(jessica.age);console.log(jessica.__proto__ === PersonCl.prototype); // true// PersonCl.prototype.greet = function () &#123;// console.log(`Hey $&#123;this.firstName&#125;`);// &#125;;jessica.greet(); Setters and GettersStatic Methods and Instance MethodsObject.create() 1234567891011121314151617181920212223// Object.createconst PersonProto = &#123; calcAge() &#123; console.log(2037 - this.birthYear); &#125;, init(firstName, birthYear) &#123; this.firstName = firstName; this.birthYear = birthYear; &#125;,&#125;;const steven = Object.create(PersonProto);console.log(steven);steven.name = &#x27;Steven&#x27;;steven.birthYear = 2002;steven.calcAge();console.log(steven.__proto__ === PersonProto); // trueconst sarah = Object.create(PersonProto);sarah.init(&#x27;Sarah&#x27;, 1979);sarah.calcAge(); Inheritance between Classes"},{"title":"Sets_and_Maps","path":"/wiki/JavaScript/Sets_and_Maps.html","content":"Sets and mapsIn ex6 ,two more data structures were finally introduced. Set is iterable SetsBasic usageUse new Set() to creat a new set. 12const set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);console.log(set);//Set(3) &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125; 12const set = new Set(&#x27;aniya&#x27;);console.log(set);//Set(4) &#123; &#x27;a&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;y&#x27; &#125; The input must be iterable. And the elements in a set is unique. And there is no order of the elements. No index. So there is no need to get a value form sets. Methods of set .size 12const set //4= new Set(&#x27;aniya&#x27;);console.log(set.size);//4 .has() 12const set = new Set(&#x27;aniya&#x27;);console.log(set.has(&#x27;a&#x27;), set.has(&#x27;0&#x27;));//true false To find out whether the set has the thing you want to know. .add() 1234const set = new Set();console.log(set);//Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set);//Set(1) &#123; &#x27;Tommy idiot&#x27; &#125; You can just add one at one time. .delete 123456const set = new Set();console.log(set); //Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set); //Set(1) &#123; &#x27;Tommy idiot&#x27; &#125;set.delete(&#x27;Tommy idiot&#x27;);console.log(set);//Set(0) &#123;&#125; .clear() 123const set = new Set(&#x27;aniya&#x27;);set.clear();console.log(set);//Set(0) &#123;&#125; To clear out the set. Loop over the set12345678const set = new Set(&#x27;aniya&#x27;);for (const item of set) &#123; console.log(item);&#125;//a//n//i//y Some usecases of sets To remove duplicated values of arrarys. 123const arr = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4];const arrUnique = [...new Set(arr)];console.log(arrUnique);//[ 1, 2, 3, 4 ] And we can konw its size by the size method. Maps Maps is alike to objects,data are also stored as key-value pairs. The biggest diffrence is that keys in maps can be any type,such as number, string ,object and even another map. While the keys in objects can only be string. Creat a map1234567891011const question = new Map([ [&#x27;key&#x27;, &#x27;value&#x27;], [&#x27;question&#x27;, &quot;What&#x27;s the best programming language in the world?&quot;], [1, &#x27;C&#x27;], [2, &#x27;Java&#x27;], [3, &#x27;Javascript&#x27;], [&#x27;correct&#x27;, 3], [true, &#x27;Congratulations! 🤣&#x27;], [false, &#x27;Try again!😅&#x27;],]);console.log(question); The argument is a big arrary which contains many small arrarys which are compose of key-value pairs. .set()1234567891011121314let o = &#123; name: &#x27;jonas&#x27;,&#125;;const map = new Map();map.set(1, &#x27;the first&#x27;);map.set(&#x27;key&#x27;, 2);map.set(o, o);console.log(map.set(o, o));console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; Calling the set method like this does not only update the map that’s called on,but it also returns the map. So you can just do that like this: 1234567map.set(1, &#x27;the first&#x27;).set(o, o).set(&#x27;key&#x27;, 2);console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; .get()1console.log(map.get(&#x27;key&#x27;));//2 .has().delete()If you want to use an “Complex datatype” as an key ,you should store it in an variation first. Wrong 123const map = new Map();map.set([1, 2], &#x27;this&#x27;);console.log(map.get([1, 2]));//undefined Because the two [1,2] is not the same object that is stored in heap. Right 1234const map = new Map();const arr = [1, 2];map.set(arr, &#x27;this&#x27;);console.log(map.get(arr)); //this Convert a object into a map.1newMap = new Map(Object.entries(objectName)); Loop over a map123for(const [key,value] of mapName)&#123;\tconsole.log(key,value);&#125;"},{"title":"Spread_Operator","path":"/wiki/JavaScript/Spread_Operator.html","content":"Spread OperatorDeconstruct the values in the array, suitable for the comma separation (this applies to all iterables) Iterables:arrary, strings, maps, sets.Not objects Usually separated by commas: a function passes arguments, builds a new array 1234const arr = [7, 8, 9];const newArr = [1, 2, ...arr];console.log(newArr);//(5) [1, 2, 7, 8, 9]console.log(...newArr);//1 2 7 8 9 Application Shallow copy ``` jslet newArr = […oldArr];12345- Combine arrays - ``` js const Arr = [...Arr1,...Arr2]; 1console.log(...&quot;jonas&quot;);//j o n a s Specially Works for object, too. 1let newObj = &#123; ...oldObj,name:&quot;tom&quot;&#125; 以此来实现对象的浅拷贝 Rest PatternIt’s similar to the spread pattern, but the three dots are on the left. Example: 12const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);//1 2 (4) [3, 4, 5, 6] the Rest element must be the last one in []. Of course, object can use it too. In Function123456const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);const add = function (...numbers) &#123; console.log(numbers);&#125;;add(1, 2, 3, 45, 6, 56, 45, 755, 3, 57);//(10) [1, 2, 3, 45, 6, 56, 45, 755, 3, 57]"},{"title":"Which_Data_Structure_to_Use","path":"/wiki/JavaScript/Which_Data_Structure_to_Use.html","content":"Which data structure to use?Sourece Of Data From the program itself From the UI From external sources For Simple List: Arrays or SetsArrays Use when you need ordered list of values (might contain duplicates) Use when you need to manipulate data Sets Use when you need to work with unique values Use when high-performance is really important Use to remove duplicates from arrays For Key/Value Pairs: Objects or MapsObjects Features More “traditional” key/value store(“abused” objects) Easier to write and access values with . and [ ] Use when you need to include functions(methods) working with JSON(can convert to map) Maps Features Better performance Keys can have any data type Easy to iterate Easy to compute size Use when you simply need to map key to values you need keys that are not strings"},{"title":"Optional_Chaining","path":"/wiki/JavaScript/Optional_Chaining.html","content":"？Now if you want to know whether a restaurant’s opening hours in Monday 1console.log(restaurant.openingHours.mon); If mon is not exist, it will be undefined, not a big deal. But if openingHours is not exist ,it will be a error. So we can solve this problem with the ? 1console.log(restaurant.openingHours?.mon); We can also use it to use method. 1console.log(restaurant.order?.(0,1) ?? &#x27;Method does not exist.&#x27;)"},{"title":"String","path":"/wiki/JavaScript/Working_with_Strings.html","content":"Working With Stringsmethods Return new strings .length .indexOf() 123const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.indexOf(&#x27;Portugal&#x27;));//8console.log(airline.indexOf(&#x27;portugal&#x27;));//-1 ​ Case sensetive* .lastIndexOf() 12const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.lastIndexOf(&#x27;r&#x27;));//10 The last ‘r’. .slice() 1234const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.slice(4));//Air Portugalconsole.log(airline.slice(4, 7));//Airconsole.log(airline.slice(-2));//al It returns a new string. The end value is not included in the new string. When the argument is negative, it will count from the end. .toLowerCase() .toUpperCase() .trim() .replace() You can use regular expression here. 1console.log(airline.replaceAll(/A/g, &#x27;a&#x27;));//TaP air Portugal It replaced all ‘A’. .replaceAll() .repeat() 1234const planesInLine = function (n) &#123; console.log(`There are $&#123;n&#125; planes in line $&#123;&#x27;✈️&#x27;.repeat(n)&#125;`);&#125;;planesInLine(10);//There are 10 planes in line ✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️ Return booleans. .includes() .startsWith() endsWith() We do know that string is a type of primitives,why it has methods?Because javascript automaticlly will turn the string into an object,and when the operation is done, it will turn back into a string primitive. So all string methods return primitives, even if called on a string object. 12console.log(typeof new String(&#x27;aniya&#x27;)); //objectconsole.log(typeof new String(&#x27;aniya&#x27;).slice(-1));//string Other important method:split() join() split() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.split(&#x27;+&#x27;));//[ &#x27;qwer&#x27;, &#x27;zxcv&#x27;, &#x27;ajf0s&#x27;, &#x27;sjaf&#x27; ] join() ​ Input an array,return a string. 123const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;const strSplit = str.split(&#x27;+&#x27;);console.log(strSplit.join(&#x27;---&#x27;));//qwer---zxcv---ajf0s---sjaf Padding Methods padStart() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padStart(30, &#x27;)+&#x27;));//)+)+)+)+)+qwer+zxcv+ajf0s+sjaf padEnd() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padEnd(30, &#x27;)+&#x27;));//qwer+zxcv+ajf0s+sjaf)+)+)+)+)+"},{"title":"前言","path":"/wiki/JavaScript/index.html","content":"听JS教程留下的一部分笔记 为了拯救我那很烂的英语🙌，笔记主要是英文（自己后来也可能看不懂🤣🤣 上传的第一篇笔记😎😎😎"}]