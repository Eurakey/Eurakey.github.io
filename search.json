[{"title":"pytorch-learning","path":"/2023/03/21/pytorch-learning/","content":"两大法宝函数 dir()：打开、看见 help():说明书如何加载数据 Dataset Dataloader1234567891011121314151617181920212223242526from torch.utils.data import Dataset from PIL import Image # 操作图片import os # 操作系统 class MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(root_dir, label_dir) self.img_path = os.listdir(self.path) def __getitem__(self, idx): # 内置函数 img_name = self.img_path[idx] img_item_path = os.path.join(self.root_dir, self.label_dir, img_name) img = Image.open(img_item_path) label = self.label_dir return img, label def __len__(self): return len(self.img_path) root_dir = &quot;dataset/train&quot; ants_label_dir = &quot;ants_image&quot; ants_dataset = MyData(root_dir, ants_label_dir) TensorBoard123456789101112131415161718from torch.utils.tensorboard import SummaryWriter import numpy as np from PIL import Image writer = SummaryWriter(&quot;logs&quot;) image_path = &quot;dataset/train/ants_image/0013035.jpg&quot; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) print(img_array.shape) writer.add_image(&quot;test&quot;, img_array, 1, dataformats=&quot;HWC&quot;) # writer.add_scalar() for i in range(100): writer.add_scalar(&quot;y=2x&quot;, 2*i, i) writer.close() Transforms结构及用法transforms.py 工具箱 totensor resize通过 transforms.ToTensor去看两个问题 transforms该如何使用(python) 为什么我们需要Tensor数据类型1234567891011121314from torch.utils.tensorboard import SummaryWriter from torchvision import transforms from PIL import Image img_path = &quot;dataset/train/ants_image/0013035.jpg&quot; img = Image.open(img_path) writer = SummaryWriter(&quot;logs&quot;) tensor_trans = transforms.ToTensor() # 创建工具 tensor_img = tensor_trans(img) # 使用工具 writer.add_image(&quot;Tensor_img&quot;, tensor_img) writer.close() 常见的Transforms 输入 PIL Image.open() 输出 tensor ToTensor() 作用 narays cv.imread()123456789101112131415161718192021222324252627282930313233343536373839from PIL import Image from torchvision import transforms from torch.utils.tensorboard import SummaryWriter writer = SummaryWriter(&quot;logs&quot;) img = Image.open(&quot;dataset/train/ants_image/0013035.jpg&quot;) #ToTensor trans_tensor = transforms.ToTensor() img_tensor = trans_tensor(img) writer.add_image(&quot;ToTensor&quot;, img_tensor) # Normalize print(img_tensor[0][0][0]) trans_norm = transforms.Normalize([1, 3, 5], [1, 1, 1]) img_norm = trans_norm(img_tensor) print(img_norm[0][0][0]) writer.add_image(&quot;Normalize&quot;, img_norm, 1) # Resize print(img.size) trans_resize = transforms.Resize((512, 512)) img_resize = trans_resize(img) print(img_resize.size) # Compose trans_compose = transforms.Compose([trans_resize, trans_tensor]) img_compose = trans_compose(img) writer.add_image(&quot;compose&quot;, img_compose, 1) # RandomCrop trans_random = transforms.RandomCrop((500, 1000)) trans_compose_2 = transforms.Compose([trans_random, trans_tensor]) for i in range(10): img_crop = trans_compose_2(img) writer.add_image(&quot;RandomCrop&quot;, img_crop, i) writer.close() 工具食用方法关注输入输出，官方文档torchvision中的数据集使用在PyTorch中，train=True表示使用CIFAR-10数据集的训练集，而train=False表示使用测试集。在训练模型时，我们使用训练集来训练模型，然后使用测试集来评估模型的性能。因此，我们需要将数据集分成训练集和测试集.12345678910111213141516171819202122232425import torchvision from PIL import Image from torch.utils.tensorboard import SummaryWriter dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) train_set = torchvision.datasets.CIFAR10(root=&quot;./data&quot;, train=True, transform=dataset_transform, download=True) test_set = torchvision.datasets.CIFAR10(root=&quot;./data&quot;, train=False, transform=dataset_transform, download=True) print(test_set.classes) # img, target = test_set[0] # print(img) # print(target) # print(test_set.classes[target]) # img.show() # print(test_set[0]) write = SummaryWriter(&quot;p10&quot;) for i in range(10): img, target = test_set[i] write.add_image(&quot;test_set&quot;, img, i) write.close() DataLoader dataset：要从中加载数据的数据集。 batch_size：每个批次中的样本数。 shuffle：是否对数据进行洗牌。 num_workers：用于数据加载的子进程数。 drop_last：如果数据集大小不能被批次大小整除，则是否删除最后一个不完整的批次神经网络的基本骨架nn.Module是PyTorch中所有神经网络模块的基类。它包含层和一个方法forward(input)，该方法返回输出。它是一种方便的封装参数的方法，具有将它们移动到GPU、导出、加载等的帮助程序。您的模型也应该继承这个类。模块也可以包含其他模块，允许将它们嵌套在树形结构中。您可以将子模块分配为常规属性。1234567891011121314151617import torch from torch import nn class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() def forward(self, input): output = input + 1 return output tudui = Tudui() x = torch.tensor(1.0) output = tudui(x) print(output) 卷积操作123456789101112131415161718192021222324252627import torch import torch.nn.functional as F input = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]]) kernel = torch.tensor([[1, 2, 1], [0, 1, 0], [2, 1, 0]]) input = torch.reshape(input, (1, 1, 5, 5)) # 增加batchsize和channel kernel = torch.reshape(kernel, (1, 1, 3, 3)) print(input.shape) print(kernel.shape) output = F.conv2d(input, kernel, stride=1) output2 = F.conv2d(input, kernel, stride=2) output3 = F.conv2d(input, kernel, stride=1, padding=1) print(output) print(output2) print(output3) torch.nn.Conv2d是一个类，它可以创建一个二维卷积层，而torch.nn.functional.conv2d是一个函数，它可以对一个输入图像进行二维卷积操作。 你的代码中有三个conv2d的调用，它们的区别是： output = F.conv2d(input, kernel, stride=1)：这个调用没有使用padding参数，所以输出的形状是(1, 1, 3, 3)。 output2 = F.conv2d(input, kernel, stride=2)：这个调用使用了stride参数为2，所以输出的形状是(1, 1, 2, 2)。 output3 = F.conv2d(input, kernel, stride=1, padding=1)：这个调用使用了padding参数为1，所以输出的形状是(1, 1, 5, 5)。 神经网络-卷积层12345678910111213141516171819202122232425262728293031323334353637import torch import torchvision from torch import nn from torch.nn import Conv2d from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter dataset = torchvision.datasets.CIFAR10(&quot;data&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True) dataloader = DataLoader(dataset, 64, shuffle=True) class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size= 3, stride=1, padding=0) def forward(self, x): x = self.conv1(x) return x tudui = Tudui() writer = SummaryWriter(&quot;p11&quot;) step = 0 for data in dataloader: imgs, targets = data output = tudui(imgs) writer.add_images(&quot;input&quot;, imgs, step) output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(&quot;output&quot;, output, step) step += 1 代码中有两个部分，一个是数据集和数据加载器的定义，另一个是自定义卷积层类Tudui的定义和使用。 数据集和数据加载器的定义：这里你使用了torchvision.datasets.CIFAR10来下载并加载CIFAR10数据集，它包含了60000张32x32的彩色图像，分为10个类别。你使用了torchvision.transforms.ToTensor()来把图像转换为张量，并且只加载了测试集。你使用了torch.utils.data.DataLoader来创建一个数据加载器，它可以按照批次大小为64，随机打乱顺序地提供数据。 自定义卷积层类Tudui的定义和使用：这里你继承了torch.nn.Module类来创建一个自定义卷积层类Tudui。在__init__方法中，你使用了torch.nn.Conv2d来创建一个二维卷积层，它可以把输入通道数为3的图像转换为输出通道数为6的特征图，使用了3x3的卷积核，步长为1，没有填充。在forward方法中，你把输入x通过self.conv1进行卷积操作，并返回结果。然后你创建了一个Tudui的实例tudui，并用它对dataloader中的每一批图像进行处理。你使用了torch.utils.tensorboard.SummaryWriter来创建一个写入器writer，并用它把输入图像和输出特征图写入到TensorBoard中。神经网络-最大化池的使用最大池化（Max Pooling）是一种常用的池化操作，它可以减少特征图的大小，降低计算量和内存消耗，同时保留最重要的特征。 kernel_size：滤波器的大小，也就是每次取最大值的窗口大小。可以是一个整数，表示窗口是正方形的，也可以是一个元组，表示窗口是矩形的。 stride：滤波器的步长，也就是每次移动的距离。默认值是kernel_size，表示没有重叠。可以是一个整数，表示水平和垂直方向上都相同，也可以是一个元组，表示水平和垂直方向上不同。 padding：在输入特征图两边添加的填充值。默认值是0，表示不添加填充。可以是一个整数，表示两边都相同，也可以是一个元组，表示两边不同。填充值为负无穷大（-inf），表示被忽略。 dilation：滤波器中元素之间的间隔。默认值是1，表示没有间隔。可以是一个整数，表示水平和垂直方向上都相同，也可以是一个元组，表示水平和垂直方向上不同。 return_indices：是否返回最大值对应的索引。默认值是False，表示不返回。如果为True，则返回一个与输出形状相同的张量（tensor），包含每个最大值在输入特征图中的位置（行列号）。这个参数在后续使用torch.nn.MaxUnpool2d进行反池化时有用。 ceil_mode：是否使用向上取整而不是向下取整来计算输出形状。默认值是False，表示使用向下取整。如果为True，则使用向上取整。12345678910111213141516171819202122232425262728293031323334import torch import torchvision from torch import nn from torch.nn import MaxPool2d from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter dataset = torchvision.datasets.CIFAR10(&quot;data&quot;, train=False, download=True, transform=torchvision.transforms.ToTensor()) dataloader = DataLoader(dataset, batch_size=64) class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True) def forward(self, input): output = self.maxpool1(input) return output tudui = Tudui() writer = SummaryWriter(&quot;logs_maxpool&quot;) step = 0 for data in dataloader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, step) output = tudui(imgs) writer.add_images(&quot;output&quot;, output, step ) step = step + 1 writer.close() 神经网络-非线性激活非线性激活函数是指在神经网络的神经元上运行的函数，负责将神经元的输入映射到输出端。非线性激活函数对于神经网络去学习、理解非常复杂和非线性的函数来说具有十分重要的作用。它们将非线性特性引入到网络中。 如果我们的神经网络只使用线性激活函数，则无论多深的网络最终输出也不过是所以输入的简单线性组合，这并不具有拟合任意函数的能力，因此我们需要引入非线性激活函数。 1234567891011121314151617181920import torch from torch import nn from torch.nn import ReLU input = torch.tensor([[1, -0.5], [-1, 3]]) torch.reshape(input, (-1, 1, 2, 2)) class TuDui(nn.Module): def __init__(self): super(TuDui, self).__init__() self.relu1 = ReLU() def forward(self, input): output = self.relu1(input) return output tudui = TuDui() output = tudui(input) print(output) 神经网络-线性层及其他层介绍线性层是一种神经网络中的基本模块，它使用一个权重矩阵对输入特征进行线性变换，得到输出特征。线性层的输入和输出都是二维张量，形状为[batch_size, size]。线性层可以用于实现全连接层，即每个输入神经元与每个输出神经元都有连接。 线性层的参数有： in_features：输入特征的数量，即输入张量的列数 out_features：输出特征的数量，即输出张量的列数 bias：是否添加偏置项，默认为TrueSequential的使用它有三个卷积层，三个最大池化层，两个全连接层和一个Flatten层。它的输入是一个64x3x32x32的张量，输出是一个64x10的张量。你还使用了SummaryWriter来可视化你的模型结构。123456789101112131415161718192021222324252627282930313233343536import torch from torch import nn from torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequential from torch.utils.tensorboard import SummaryWriter class TuDui(nn.Module): def __init__(self): super(TuDui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return x tudui = TuDui() print(tudui) input = torch.ones((64, 3, 32, 32)) output = tudui(input) print(output.shape) writer = SummaryWriter(&quot;logs_seq&quot;) writer.add_graph(tudui, input) writer.close() 损失函数与反向传播神经网络的损失函数是用来衡量网络输出与期望输出之间的差异，反向传播是一种算法，用来计算损失函数对网络参数的梯度，并根据梯度更新参数，使损失函数达到最小神经网络的梯度是一个重要的概念，它指示了在函数的某一点，沿着哪个方向函数值上升最快，以及上升的速度有多快12345678910111213141516171819202122232425262728293031323334353637383940import torch import torchvision from torch import nn from torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequential, CrossEntropyLoss from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter dataset = torchvision.datasets.CIFAR10(&quot;data&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True) dataloader = DataLoader(dataset, batch_size=1) class TuDui(nn.Module): def __init__(self): super(TuDui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return x tudui = TuDui() loss = CrossEntropyLoss() for data in dataloader: imgs, targets = data outputs = tudui(imgs) result_loss = loss(outputs, targets) print(result_loss) result_loss.backward() 现有网络模型的使用及修改如果你想使用预训练模型，你可以参考 Pytorch 的官方文档或者 Pytorch Hub，那里有很多现成的模型和示例代码。 如果你想自定义模型，你需要继承 torch.nn.Module 类，并实现 init 和 forward 方法。init 方法用于定义模型的层和参数，forward 方法用于定义模型的前向传播逻辑。12 无论是使用预训练模型还是自定义模型，你都需要保存和加载模型的状态字典（state_dict），这是一个包含了每个网络层和其对应参数张量的 Python 字典。34 你可以使用 torch.save 和 torch.load 函数来保存和加载状态字典。34 如果你想在不同的设备上保存和加载模型（比如 CPU 和 GPU），你需要注意指定正确的设备信息。 【学习笔记】【Pytorch】十四、现有网络模型的使用及修改_pytorch 修改网络结构_Mr庞.的博客-CSDN博客 网络模型的保存与读取网络模型的保存与读取是一个常见的需求，它可以帮助我们在不同的设备或场景下使用已经训练好的模型。 不同的深度学习框架有不同的方法来保存和读取网络模型，这里我以 Pytorch 为例，给你简单介绍一下。 Pytorch 提供了两种保存和读取网络模型的方式： 第一种是保存整个网络模型，包括模型结构和参数。这种方式可以直接使用 torch.save(model, ‘model.pth’) 和 model = torch.load(‘model.pth’) 函数来实现。1 第二种是只保存网络参数，也就是状态字典（state_dict）。这种方式可以使用 torch.save(model.state_dict(), ‘model_params.pth’) 和 model.load_state_dict(torch.load(‘model_params.pth’)) 函数来实现。21 Pytorch 官方推荐使用第二种方式，因为它更灵活和通用，而且占用的空间更小。2 无论哪种方式，你都需要注意在不同设备上保存和加载模型时指定正确的设备信息（比如 CPU 或 GPU）。21 完整的模型训练套路argmax 是一个数学函数，它用于找到使目标函数取得最大值的输入（或参数）。1 在机器学习中，argmax 常用于找到具有最大预测概率的类别。2 例如，如果有一个分类器可以对一张图片进行四种类别的预测（猫、狗、鸟、鱼），并输出每种类别的概率（0.2、0.3、0.4、0.1），那么 argmax 操作可以返回最大概率对应的类别（鸟）或者索引（2）。 在 Python 中，可以使用 numpy.argmax() 函数来实现 argmax 操作。34 这个函数接受一个数组作为输入，并返回沿着指定轴的最大值的索引。如果没有指定轴，则返回整个数组中的最大值的索引。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import torch import torchvision from torch.utils.tensorboard import SummaryWriter from model import Tudui # 准备数据集 from torch import nn from torch.utils.data import DataLoader train_data = torchvision.datasets.CIFAR10(&quot;data&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True) test_data = torchvision.datasets.CIFAR10(&quot;data&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True) # 长度 train_data_size = len(train_data) test_data_size = len(test_data) print(&quot;训练数据集的长度为：&#123;&#125;&quot;.format(train_data_size)) print(&quot;测试数据集的长度为：&#123;&#125;&quot;.format(test_data_size)) # 利用DataLoader来加载数据 train_dataloader = DataLoader(train_data, batch_size=64) test_dataloader = DataLoader(test_data, batch_size=64) # 创建网络模型 tudui = Tudui() # 损失函数 loss_fn = nn.CrossEntropyLoss() # 优化器 learing_rate = 1e-2 ooptimizer = torch.optim.SGD(tudui.parameters(), lr=learing_rate) # 设置训练网络的一些参数 # 记录训练次数 total_train_step = 0 # 记录测试的次数 total_test_step = 0 #训练的轮数 epoch = 10 # 添加tensorboard writer = SummaryWriter(&quot;logs_train&quot;) for i in range(epoch): print(&quot;----------------------------第&#123;&#125;轮训练开始----------------------------------&quot;.format(i+1)) # 训练步骤开始 tudui.train() for data in train_dataloader: imgs, targets = data outputs = tudui(imgs) loss = loss_fn(outputs, targets) # 优化器优化模型 ooptimizer.zero_grad() loss.backward() ooptimizer.step() total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;训练次数：&#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step, loss.item())) writer.add_scalar(&quot;train_loss&quot;, loss.item(), total_train_step) # 测试步骤开始 tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;整体测试集上的Loss：&#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率：&#123;&#125;&quot;.format(total_accuracy/ test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy/test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;模型已保存&quot;) writer.close() 利用GPU训练1. 找到 - 网络模型 - 数据（输入输出） - 损失函数 .cuda() 2. .to(device) device = torch.device(&quot;cpu&quot;) Torch.device(&quot;cuda&quot;) 完整的模型验证套路(测试， demo)利用已经训练好的模型，然后给它提供输入 123456789101112131415161718192021222324import torch import torchvision from PIL import Image from torch import nn # 传入图片处理 img_path = &quot;./imgs/dog.jpg&quot; img = Image.open(img_path) img = img.convert(&quot;RGB&quot;) transform = torchvision.transforms.Compose([ torchvision.transforms.Resize((32, 32)), torchvision.transforms.ToTensor() ]) img = transform(img) img = torch.reshape(img, (1, 3, 32, 32)) img = img.cuda() # 开始识别 model = torch.load(&quot;tudui_0.pth&quot;) model.cuda() model.eval() with torch.no_grad(): output = model(img) print(output.argmax(1))","tags":["python","pytorch"]},{"title":"GPG简要入门指南","path":"/2023/02/23/gpg/","content":"什么是GPG？ GPG 是一个加密、解密、签名、验证工具。 加密：对信息进行加密，有对称加密和非对称加密 解密：对加密的信息解密 签名：对发出的信息签名，使他人能验证信息为本人发出，且未被篡改过 验证：对接收到的签名的信息进行验证 GPG 还是一个密钥管理工具 管理自己的私钥，其他人的公钥，以及提供了一套公钥信任体系。安装下载安装 GPG：访问 GPG官网，下载适合自己操作系统平台的安装程序。安装完成后，打开 CMD 窗口，输入 gpg --version验证是否安装成功出现下列信息表示成功123456789101112131415C:\\Users ame&gt;gpg --versiongpg (GnuPG) 2.4.0libgcrypt 1.10.1Copyright (C) 2021 g10 Code GmbHLicense GNU GPL-3.0-or-later &lt;https://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Home: C:\\Users ame\\AppData\\Roaming\\gnupgSupported algorithms:Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSACipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224Compression: Uncompressed, ZIP, ZLIB, BZIP2 开始使用输入gpg -help列出所有指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Commands: -s, --sign make a signature --clear-sign make a clear text signature -b, --detach-sign make a detached signature -e, --encrypt encrypt data -c, --symmetric encryption only with symmetric cipher -d, --decrypt decrypt data (default) --verify verify a signature -k, --list-keys list keys --list-signatures list keys and signatures --check-signatures list and check key signatures --fingerprint list keys and fingerprints -K, --list-secret-keys list secret keys --generate-key generate a new key pair --quick-generate-key quickly generate a new key pair --quick-add-uid quickly add a new user-id --quick-revoke-uid quickly revoke a user-id --quick-set-expire quickly set a new expiration date --full-generate-key full featured key pair generation --generate-revocation generate a revocation certificate --delete-keys remove keys from the public keyring --delete-secret-keys remove keys from the secret keyring --quick-sign-key quickly sign a key --quick-lsign-key quickly sign a key locally --quick-revoke-sig quickly revoke a key signature --sign-key sign a key --lsign-key sign a key locally --edit-key sign or edit a key --change-passphrase change a passphrase --export export keys --send-keys export keys to a keyserver --receive-keys import keys from a keyserver --search-keys search for keys on a keyserver --refresh-keys update all keys from a keyserver --import import/merge keys --card-status print the card status --edit-card change data on a card --change-pin change a card&#x27;s PIN --update-trustdb update the trust database --print-md print message digests --server run in server mode --tofu-policy VALUE set the TOFU policy for a keyOptions controlling the diagnostic output: -v, --verbose verbose -q, --quiet be somewhat more quiet --options FILE read options from FILE --log-file FILE write server mode logs to FILEOptions controlling the configuration: --default-key NAME use NAME as default secret key --encrypt-to NAME encrypt to user ID NAME as well --group SPEC set up email aliases --openpgp use strict OpenPGP behavior -n, --dry-run do not make any changes -i, --interactive prompt before overwritingOptions controlling the output: -a, --armor create ascii armored output -o, --output FILE write output to FILE --textmode use canonical text mode -z N set compress level to N (0 disables)Options controlling key import and export: --auto-key-locate MECHANISMS use MECHANISMS to locate keys by mail address --auto-key-import import missing key from a signature --include-key-block include the public key in signatures --disable-dirmngr disable all access to the dirmngrOptions to specify keys: -r, --recipient USER-ID encrypt for USER-ID -u, --local-user USER-ID use USER-ID to sign or decrypt(See the man page for a complete listing of all commands and options)Examples: -se -r Bob [file] sign and encrypt for user Bob --clear-sign [file] make a clear text signature --detach-sign [file] make a detached signature --list-keys [names] show keys --fingerprint [names] show fingerprintsPlease report bugs to &lt;https://bugs.gnupg.org&gt;. 生成密匙输入gpg --gen-key生成依据提示输入名称、电子邮箱等信息后输出密匙的相关信息1234567891011121314151617181920212223242526Note: Use &quot;gpg --full-generate-key&quot; for a full featured key generation dialog.GnuPG needs to construct a user ID to identify your key.Real name: xxxxEmail address: xxxxYou selected this USER-ID: &quot;xxxx &lt;xxxx@qq.com&gt;&quot;Change (N)ame, (E)mail, or (O)kay/(Q)uit? oWe need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.We need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.gpg: directory &#x27;C:\\\\Users\\ ame\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d&#x27; createdgpg: revocation certificate stored as &#x27;C:\\\\Users\\ ame\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d\\\\064E4BB07566BA558B6B006A4BF6180BAB71781D.rev&#x27;public and secret key created and signed.pub ed25519 2023-02-23 [SC] [expires: 2025-02-22] 064E4BB07566BA558B6B006A4BF6180BAB71781Duid xxxx &lt;xxxx@qq.com&gt;sub cv25519 2023-02-23 [E] [expires: 2025-02-22] 其中064E4BB07566BA558B6B006A4BF6180BAB71781D这是”用户ID”的Hash字符串，可以用来替代”用户ID”。查看密匙列表输入gpg --list-keys如果你要从密钥列表中删除某个密钥，可以使用delete-key参数。1gpg --delete-key [用户ID] 加密和解密这个过程是对文件进行的 加密：```1gpg --recipient [用户ID] --output [加密文件输出路径] --encrypt [加密文件输入路径] 解密：1gpg [加密文件路径] 签名有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。 1gpg --sign test.txt 然后生成了一个test.txt.gpg文件，我们打开这个文件后，发现这也是一个二进制的数据，这并不是加密后的数据，与上边的二进制数据不一样。如果想生成ASCII码的签名文件，可以使用clearsign参数 1gpg --clearsign test.txt 如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。 1gpg --detach-sign test.txt 是一个二进制的数据，如果想采用ASCII码形式，要加上armor参数 1gpg --armor --detach-sign test.txt 验证签名我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证 1gpg --verify test.txt.asc test.txt","tags":["tools"]},{"title":"高阶函数、声明式和命令式编程","path":"/2023/01/20/高阶函数、声明式和命令式编程/","content":"高阶函数、命令式编程和声明式编程什么是高阶函数？ 以函数作为参数 以函数作为返回值 常用于函数装饰器 12345let HOFO = function (fn) &#123; return function (...args) &#123; return fn.apply(this, args); &#125;;&#125;; 高阶函数的好处 高阶函数的魅力在于它的可重复利用性，如果不是高阶函数，map、filter、reduce 等强大的数组函数就不可能存在。 使 JavaScript 适合函数式编程的原因是它接受高阶函数。 常用高阶函数示例防抖和节流节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 once 让函数只执行一次，常用于节流 ```jslet once = function (fn) { return function (…args) { if (fn) &#123; setTimeout(() =&gt; &#123; fn = null; &#125;); return fn.apply(this, args); &#125; };}; 1234567891011121314151617- throttle - 让函数在执行后的一段时间不能被再次触发 - ```js let throttle = function (fn, time = 500) &#123; let timer; return function (...args) &#123; if (timer == null) &#123; fn.apply(this, args); timer = setTimeout(() =&gt; &#123; timer = null; &#125;, time); &#125; &#125;; &#125;; consumer 将多次触发的任务加入任务队列，依次间隔执行 ```jsfunction consumer(fn, time){ let tasks = [], timer; return function(…args){ tasks.push(fn.bind(this, ...args)); if(timer == null)&#123; timer = setInterval(() =&gt; &#123; tasks.shift().call(this) if(tasks.length &lt;= 0)&#123; clearInterval(timer); timer = null; &#125; &#125;, time) &#125; }} 123456789101112131415#### 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时- debounce - ```js let debounce = function (fn, time) &#123; let timer; return function (...args) &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; return fn.apply(this, args); &#125;, time); &#125;; &#125;; 非纯函数和纯函数(pure function)什么是纯函数和非纯函数 纯函数是指在给定输入的参数下，输出总是确定的，不依赖于外界环境 例如： 12let add = (a, b) =&gt; a + b;//add返回的值只与输入参数有关 非纯函数依赖上下文 例如： 123let count = 0;let add = () =&gt; count++;//add返回的值依赖于count的值 如果代码中非纯函数过多，代码会变得难以维护，所以我们要减少写出非纯函数 将非纯函数转化为纯函数123456789101112131415const isIterable = obj =&gt; obj != null &amp;&amp; typeof obj[Symbol.iterator] === &#x27;function&#x27;;function iterative(fn) &#123; return function(subject, ...rest) &#123; if(isIterable(subject)) &#123; const ret = []; for(let obj of subject) &#123; ret.push(fn.apply(this, [obj, ...rest])); &#125; return ret; &#125; return fn.apply(this, [subject, ...rest]); &#125;&#125; 这里的iterative和isIterable都是纯函数，它们能方便地对可迭代对象批量执行函数 例如假如现在有一个setColor函数能改变元素的颜色，如果这时我们要对元素批量执行，再定义一个setColors的话就产生了两个非纯函数，而如果我们利用上面的iterative函数就可以直接将setColor函数传入其中，实现批量操作，减少了非纯函数的产生。 命令式和声明式编程以改变一个按钮的状态为例 命令式编程关注怎么做 ```jsswitcher.onclick = function(evt){ if(evt.target.className === ‘on’){evt.target.className = &#39;off&#39;; }else{evt.target.className = &#39;on&#39;; }}12345678910111213141516- 声明式编程关注做什么 - ```js function toggle(...actions)&#123; return function(...args)&#123; let action = actions.shift(); actions.push(action); return action.apply(this, args); &#125; &#125; switcher.onclick = toggle( evt =&gt; evt.target.className = &#x27;off&#x27;, evt =&gt; evt.target.className = &#x27;on&#x27; ); 看起来区别不大但当这个按钮有三种状态时，在命令式编程下我们需要重写if-else的逻辑，而声明式编程下我们只需要在toggle里再多传入evt =&gt; evt.target.className = &#39;warn&#39;就可以实现。","tags":["JS","青训营"]},{"title":"组件化封装","path":"/2023/01/18/组件化封装/","content":"JS组件封装 基本方法（以轮播图组件为例） 结构设计12345678910111213141516&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;slider-list__item--selected&quot;&gt; &lt;img src=&quot;xx.png&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot; &quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 展现效果 行为设计 API(功能) Event(控制流)123456789101112131415161718192021222324252627282930313233343536class Slider&#123; constructor(id)&#123; this.container = document.getElementById(id); this.items = this.container .querySelectorAll(&#x27;.slider-list__item, .slider-list__item--selected&#x27;); &#125; getSelectedItem()&#123; const selected = this.container .querySelector(&#x27;.slider-list__item--selected&#x27;); return selected &#125; getSelectedItemIndex()&#123; return Array.from(this.items).indexOf(this.getSelectedItem()); &#125; slideTo(idx)&#123; const selected = this.getSelectedItem(); if(selected)&#123; selected.className = &#x27;slider-list__item&#x27;; &#125; const item = this.items[idx]; if(item)&#123; item.className = &#x27;slider-list__item--selected&#x27;; &#125; &#125; slideNext()&#123; const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); &#125; slidePrevious()&#123; const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); &#125;&#125; 但是这样功能虽然实现，但是 可扩展性差，例如假如要加导航栏，既要改js，还要对应加上html和css 可复用性差，多次使用该组件需要多次复制相同的代码 如何改进？ 重构插件化解耦 将控制元素抽取成插件123registerPlugins(...plugins)&#123;//abstract &#125;; 插件与组件通过依赖注入方式建立联系123456789const pluginController = &#123;//abstract action(slider)&#123;//abstraction &#125;&#125;const pluginPrevious = &#123;//abstract&#125; 通过把组件的组成部分抽象成插件，我们只要在使用该组件时传入要注册的插件，就可以方便的实现组件的增删，并且后来如果还要编写新的插件也可以按原逻辑在原有js上增加。模板化 将HTML模板化。更易于扩展在插件的render方法中把组件的html模板化，123render()&#123; return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`;&#125;, 此时，组件的html代码只有短短一行1&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt;&lt;/div&gt; 抽象化(组件框架) 将组件通用模型抽象出来1234567891011121314class Component &#123; constructor(id, opts = &#123; name, data: [] &#125;) &#123; this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); &#125; registerPlugins(...plugins) &#123;//abstract &#125;; render(data) &#123;//abstract return &quot;&quot;; &#125;&#125; 这里把通用的组件模型抽象为一个Component类，后来增添新组件可通过extend关键字来继承这个component。 总结 组件设计的原则：封装性、正确性、复用性、扩展性 实现组件的步骤：结构设计、展现效果、行为设计 三次重构 插件化 模板化 抽象化","tags":["JS","青训营"]},{"title":"Array","path":"/wiki/JavaScript/Array.html","content":"ArraySimple Array Methods slice() It does not change the original array. splice() It changes the original array. 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr.splice(2)); //(3) [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]console.log(arr); //(2) [&#x27;a&#x27;, &#x27;b&#x27;] reverse() Change！ concat() 1let arr = arr1.concat(arr2); join() at()Similar to [] 123let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[0]); //aconsole.log(arr.at(0)); //a But at() can use negative index. So if we want the last element of an array. 1234let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];console.log(arr[arr.length - 1]); //econsole.log(arr.slice(-1)[0]); //econsole.log(arr.at(-1)); //e And when you use method chaining. forEach()You can not break or continue it. We can also use it in Maps and Sets map()Map returns a new array containing the results of applying an operation on all original array elements filter()filter returns a new array containing the array elements that passed a specified test condition reduce()reduce boils (‘reduces’) all array elements down to one single value(e.g. adding all elements together 1234const maxMov = movements.reduce( (acc, mov) =&gt; (acc &lt; mov ? mov : acc), movements[0]); find()findIndex()includes()some()123console.log(movements.some(mov =&gt; mov &gt; 0));//trueconst deposit = mov =&gt; mov &gt; 0;console.log(movements.some(deposit)); //true every()Similar to some(), but need all elements satisfy the condition flat()12let arr = [[1, 2, 3], 4, 5, [6, [7, 8]]];console.log(arr.flat().flat());//(8) [1, 2, 3, 4, 5, 6, 7, 8] flatMap()Similar to map(), but flat its result. sort()Change the original array. 12345let movements = [200, 450, -400, 3000, -650, -130, 70, 1300];//return &lt; 0 , A, B//return &gt; 0 , B, Amovements.sort((a, b) =&gt; a - b);console.log(movements);//(8) [-650, -400, -130, 70, 200, 450, 1300, 3000] new Array()fill()1234const x = new Array(7);console.log(x);//(7) [空 ã7]x.fill(1, 3);console.log(x);//[空 ã3, 1, 1, 1, 1] Array.from()12const x = Array.from(&#123; length: 7 &#125;, () =&gt; 1);console.log(x);//(7) [1, 1, 1, 1, 1, 1, 1] 12const x = Array.from(&#123; length: 7 &#125;, (cur, i) =&gt; i + 1);console.log(x); //(7) [1, 2, 3, 4, 5, 6, 7] Turn NodeList into an Array. 12const movementsUI = Array.from(document.querySelectorAll(&#x27;.movements__value&#x27;));console.log(movementsUI);//(8) [div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value, div.movements__value] Which Array Method to Use?To Mutate Original Array Add to original push() (end) unshift() (start) Remove from original pop() (end) shift() (start) splice() (any) Others reverse() sort() fill() A New Array Computed from original map() Filtered using condition filter() Portion of original slice() Adding original to other concat() Flattening the original flat() flatMap() An Array index Based on value includes() Based on test condition findIndex() An Array Element Based on test condition find() Konw if array includes Based on value includes() Based on test condition some() every() A New String Based on separator string join() To Transform to Value Based on accumulater reduce() To Just Loop Array Based on callback: foreach()"},{"title":"Advanced_Dom","path":"/wiki/JavaScript/Advanced_Dom.html","content":"Advanced DomHow the Dom really works?![BB93EF78E760EDFA026A6E09647E68DA](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BB93EF78E760EDFA026A6E09647E68DA.png) Selecting, Creating, and Deleting ElementsSelect1234567const queryAllButtons = document.querySelectorAll(&#x27;button&#x27;);console.log(queryAllButtons); // NodeList(9)// It is fixedconst getAllButtons = document.getElementsByTagName(&#x27;button&#x27;);console.log(getAllButtons); // HTMLCollection(9)// It updates itself as the html changes. Create12345678910111213const header = document.querySelector(&#x27;.header&#x27;);const message = document.createElement(&#x27;div&#x27;);message.classList.add(&#x27;cookie-message&#x27;);message.textContent = &#x27;We use cookied for improved functionality and analytics.&#x27;;message.innerHTML = &#x27;We use cookied for improved functionality and analytics.&lt;button class=&quot;btn btn--close-cookie&quot;&gt;Got it!&lt;/button&gt;&#x27;;header.prepend(message);header.append(message);header.after(message);header.before(message);message.remove(); Styles, Attributes and ClassesStyles123message.style.width = &#x27;120%&#x27;;console.log(message.style.width); // 120%console.log(message.style.height); // nothing Only works for the inline style. 12console.log(getComputedStyle(message)); // CSSStyleDeclarationconsole.log(getComputedStyle(message).height); // 50.6px Change the css variables 1document.documentElement.style.setProperty(&#x27;--color-primary&#x27;, &#x27;red&#x27;) Attributes12345678const logo = document.querySelector(&#x27;.nav__logo&#x27;);console.log(logo.alt); // Bankist logoconsole.log(logo.src); // http://127.0.0.1:5501/complete-javascript-course/13-Advanced-DOM-Bankist/starter/img/logo.pngconsole.log(logo.getAttribute(&#x27;src&#x27;)); // img/logo.pngconsole.log(logo.className); // nav__logologo.setAttribute(&#x27;designer&#x27;, &#x27;jonas&#x27;);console.log(logo.getAttribute(&#x27;designer&#x27;)); // jonas Data attributes 1logo.dataset Classes1234logo.classList.add(&#x27;c&#x27;);logo.classList.remove(&#x27;c&#x27;);logo.classList.toggle(&#x27;c&#x27;);logo.classList.contains(&#x27;c&#x27;); Implementing Smooth ScrollingOld school way1234567891011const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; const s1croods = section1.getBoundingClientRect(); window.scrollTo(&#123; left: s1croods.left + window.pageXOffset, top: s1croods.top + window.pageYOffset, behavior: &#x27;smooth&#x27;, &#125;);&#125;); Modern way123456const btnScrollTo = document.querySelector(&#x27;.btn--scroll-to&#x27;);const section1 = document.querySelector(&#x27;#section--1&#x27;);btnScrollTo.addEventListener(&#x27;click&#x27;, e =&gt; &#123; section1.scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;);&#125;); Type of Events and Event Handlers1234567891011121314const h1 = document.querySelector(&#x27;h1&#x27;);const alert = e =&gt; &#123; console.log(&#x27;Enter&#x27;); h1.removeEventListener(&#x27;mouseenter&#x27;, alert);&#125;;h1.addEventListener(&#x27;mouseenter&#x27;, alert);h1.addEventListener(&#x27;mouseleave&#x27;, e =&gt; &#123; console.log(&#x27;Leave&#x27;);&#125;);window.addEventListener(&#x27;keydown&#x27;, e =&gt; &#123; console.log(e);&#125;); Event Propagation_ Bubbling and CapturingEvent DelegationDom Traversing12345678910111213141516171819const h1 = document.querySelector(&#x27;h1&#x27;);//Going downwards: childconsole.log(h1.querySelectorAll(&#x27;.highlight&#x27;));console.log(h1.childNodes); // NodeList(9)console.log(h1.children); // HTMLCollection(3)h1.firstElementChild.style.color = &#x27;white&#x27;;h1.lastElementChild.style.color = &#x27;white&#x27;;// Going upwards: parentsconsole.log(h1.parentNode);console.log(h1.parentElement);h1.closest(&#x27;.header&#x27;).style.background = &#x27;var(--gradient-secondary)&#x27;;// Going sideways: siblingsconsole.log(h1.previousElementSibling);console.log(h1.nextElementSibling);console.log(h1.parentElement.children); The Intersection Observer API。。。。"},{"title":"LOOP","path":"/wiki/JavaScript/Loop.html","content":"for-of and for-in1234567891011for (const item of restaurant.starterMenu) console.log(item);//Focaccia//Bruschetta//Garlic Bread//Caprese Saladfor (const index in restaurant.starterMenu) console.log(index);//0//1//2//3//4 Item is always the current element in each iteration. Index is always the current index or property name in each iteration. You can also use if-else to break or continue the loop. Acess the item and index at the same time1234567891011for (const item of restaurant.starterMenu.entries()) console.log(item);//(2) [0, &#x27;Focaccia&#x27;]//(2) [1, &#x27;Bruschetta&#x27;]//(2) [2, &#x27;Garlic Bread&#x27;]//(2) [3, &#x27;Caprese Salad&#x27;]for (const index in restaurant.starterMenu) console.log(restaurant.starterMenu[index], index);//Focaccia 0//Bruschetta 1//Garlic Bread 2//Caprese Salad 3 So you can see we used entries()method in for-of loop entries() An Array Iterator 12console.log(...restaurant.starterMenu.entries());//(2) [0, &#x27;Focaccia&#x27;] (2) [1, &#x27;Bruschetta&#x27;] (2) [2, &#x27;Garlic Bread&#x27;] (2) [3, &#x27;Caprese Salad&#x27;] Object.entries(objectName) 12console.log(Object.entries(restaurant));//(6) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2)] Each Array is composed of the key and the value. If you want to loop a objectObject.keys(objectName)This method returns an Arrary composed by the object’s property names. 12console.log(Object.keys(restaurant));//(6) [&#x27;name&#x27;, &#x27;location&#x27;, &#x27;categories&#x27;, &#x27;starterMenu&#x27;, &#x27;mainMenu&#x27;, &#x27;openingHours&#x27;] Object.values(objectName)This method returns an Arrary composed by the object’s property values. 12console.log(Object.values(restaurant));//(6) [&#x27;Classico Italiano&#x27;, &#x27;Via Angelo Tavanti 23, Firenze, Italy&#x27;, Array(4), Array(4), Array(3), &#123;…&#125;]"},{"title":"Nullish_Coalescing_Operater_and_Or_equal","path":"/wiki/JavaScript/Nullish_Coalescing_Operater_and_Or_equal.html","content":"??Nullish: null and undefined.(Not 0 or ‘ ‘),so it’ different from || 12const value = 0 ?? 10;console.log(value);//0 12const value = null ?? 10;console.log(value);//10 12const value = undefined ?? 10;console.log(value);//10 || =12a = a||ba ||= b ??=&amp;&amp;="},{"title":"Complie_and_Interpret","path":"/wiki/JavaScript/Complie_and_Interpret.html","content":"Complilation先编译（compile）再执行（execute） Interpretation逐行编译，一边执行 Just-in-time(JIT) complilation现代javascript混合使用编译和解释,称为即时编译。"},{"title":"Numbers_and_Dates","path":"/wiki/JavaScript/Numbers_and_Dates.html","content":"Numbers and DatesNumbers12345678910111213141516171819202122232425262728// Number// Binary base 2 - 0 1console.log(23 === 23.0); //trueconsole.log(0.1 + 0.2); //0.30000000000000004// Conversionconsole.log(Number(&#x27;23&#x27;));console.log(+&#x27;23&#x27;);// Parsingconsole.log(Number.parseInt(&#x27;30px&#x27;, 10)); //30console.log(Number.parseInt(&#x27;e23&#x27;, 10)); //NaNconsole.log(Number.parseFloat(&#x27; 2.5rem&#x27;, 10)); //2.5// Check if value is NaNconsole.log(Number.isNaN(20)); //falseconsole.log(Number.isNaN(&#x27;20&#x27;)); //falseconsole.log(Number.isNaN(+&#x27;20d&#x27;)); //trueconsole.log(Number.isNaN(20 / 0)); //false// Check if value is numberconsole.log(Number.isFinite(20)); // trueconsole.log(Number.isFinite(&#x27;20&#x27;)); // falseconsole.log(Number.isFinite(20 / 0)); // falseconsole.log(Number.isInteger(20));// trueconsole.log(Number.isInteger(20.0));// true 1234567891011121314151617181920212223242526272829303132console.log(Math.sqrt(25)); // 5console.log(25 ** (1 / 2)); // 5console.log(8 ** (1 / 3)); // 2console.log(5 ** 2); // 25console.log(Math.max(1, 2, 3, 4, 5, 33, 6, 7)); //33console.log(Math.max(1, 2, 3, 4, 5, &#x27;33&#x27;, 6, 7)); //33console.log(Math.PI); // 3.141592653589793console.log(Math.random()); // Between 0 - 1console.log(Math.trunc(Math.random() * 6) + 1); // Between 1 - 6const randomInt = (max, min) =&gt; Math.trunc(Math.random() * (max - min) + 1) + min;console.log(Math.trunc(23.3)); // 23console.log(Math.round(23.3)); // 23console.log(Math.round(23.9)); // 24console.log(Math.ceil(23.3)); // 24console.log(Math.ceil(23.9)); // 24console.log(Math.floor(23.3)); // 23console.log(Math.floor(&#x27;23.9&#x27;)); // 23// Rounding decimalsconsole.log((2.7).toFixed(0)); // 3 (string)console.log((2.7).toFixed(3)); // 2.700 (string)console.log(+(2.7).toFixed(3)); // 2.7 Numeric Separators12345const diameter = 287_460_000_000;console.log(diameter); // 287460000000const price = 345_99;console.log(price);// 34599 BigInt12console.log(924363493238473294623946239747); // 9.243634932384733e+29console.log(924363493238473294623946239747n); // 924363493238473294623946239747n Operations123456const huge = 93222222244444444444444444321324n;const num = 3432;console.log(22384674238685674346n + 324739847n); // 22384674239010414193nconsole.log(huge * BigInt(num)); // 319938666742933333333333332910783968nconsole.log(huge * num);// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions 1console.log(11n / 3n); // 3n DatesCreating Dates12345678910111213//create a dateconst now = new Date();console.log(now); // Mon Jan 02 2023 15:20:12 GMT+0800 (中国标准时间)console.log(typeof now); // objectconsole.log(new Date(&#x27;Jan 02 2023 15:21:54&#x27;)); //Mon Jan 02 2023 15:21:54 GMT+0800 (中国标准时间)console.log(new Date(&#x27;December 24, 2015&#x27;)); // Thu Dec 24 2015 00:00:00 GMT+0800 (中国标准时间)console.log(new Date(2077, 12, 13, 2, 34, 89)); // Thu Jan 13 2078 02:35:29 GMT+0800 (中国标准时间)//month begins from 0;console.log(new Date(0)); // Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)console.log(new Date(3 * 24 * 60 * 60 * 1000)); // Sun Jan 04 1970 08:00:00 GMT+0800 (中国标准时间) Methods12345678910111213141516171819202122232425// Working with datesconst future = new Date(2077, 11, 13, 2, 34, 89);console.log(future); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)console.log(future.getFullYear()); // 2077console.log(future.getMonth()); // 11console.log(future.getDate()); // 13console.log(future.getHours()); // 2console.log(future.getMinutes()); // 35console.log(future.getSeconds()); // 29console.log(future.getMilliseconds()); // 0console.log(future.toISOString()); // 2077-12-12T18:35:29.000Zconst timeStamp = future.getTime();console.log(timeStamp); // 3406559729000console.log(new Date(timeStamp)); // Mon Dec 13 2077 02:35:29 GMT+0800 (中国标准时间)//TimeStamp of nowconsole.log(Date.now()); // 1672645408693//The day of this weekconsole.log(future.getDay()); // 1//Set version of these methodsfuture.setFullYear(2099);console.log(future.getFullYear()); // 2099"},{"title":"OOP","path":"/wiki/JavaScript/Object_Oriented_Programming.html","content":"Object-Oriented ProgrammingWhat is OOP? OOP is a programming paradigm based on the concept of objects We use objects to model(describe) real-world or abstract features Objects may contain data (properties) and code (methods). By using objects, we pack data and the corresponding behavior into one block. In OOP, objects are self-contained pieces/blocks of code Objects are building blocks of applications, and interact with one another Interactions happen through a public interface(API): methods that the code out side of the object can access and use to communicate with the object; Four Fundamental principles of OOP abstraction encapsulation inheritance polumorphism OOP In JS![93A0512868D930D5AD890F926DBB7C6D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\93A0512868D930D5AD890F926DBB7C6D.png) Prototypes123456789101112131415161718192021222324// Prototypesconsole.log(Person.prototype);Person.prototype.calcAge = function () &#123; console.log(2037 - this.birthYear);&#125;;jonas.calcAge();matilda.calcAge();console.log(jonas.__proto__);console.log(jonas.__proto__ === Person.prototype);console.log(Person.prototype.isPrototypeOf(jonas));console.log(Person.prototype.isPrototypeOf(matilda));console.log(Person.prototype.isPrototypeOf(Person));// .prototyeOfLinkedObjectsPerson.prototype.species = &#x27;Homo Sapiens&#x27;;console.log(jonas.species, matilda.species);console.log(jonas.hasOwnProperty(&#x27;firstName&#x27;));console.log(jonas.hasOwnProperty(&#x27;species&#x27;)); ![5E3F22E98E49E12A556E7822206F8C4D](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\5E3F22E98E49E12A556E7822206F8C4D.png) ![BAEE3FFF41CE2088CBA7EC401A89B92A](C:\\Users ame\\Documents\\Tencent Files\\747417582\\FileRecv\\MobileFile\\BAEE3FFF41CE2088CBA7EC401A89B92A.png) 12345678910111213141516171819202122// Prototypal Inheritance on Built-In Objectsconsole.log(jonas.__proto__);// Object.prototype (top of prototype chain)console.log(jonas.__proto__.__proto__);console.log(jonas.__proto__.__proto__.__proto__);console.dir(Person.prototype.constructor);const arr = [3, 6, 6, 5, 6, 9, 9]; // new Array === []console.log(arr.__proto__);console.log(arr.__proto__ === Array.prototype);console.log(arr.__proto__.__proto__);Array.prototype.unique = function () &#123; return [...new Set(this)];&#125;;console.log(arr.unique());const h1 = document.querySelector(&#x27;h1&#x27;);console.dir(x =&gt; x + 1); ES6 Classes Classes are NOT hoisted Classes are first-class citizens Classes are executed in strict mode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ES6 Classes// Class expression// const PersonCl = class &#123;&#125;// Class declarationclass PersonCl &#123; constructor(fullName, birthYear) &#123; this.fullName = fullName; this.birthYear = birthYear; &#125; // Instance methods // Methods will be added to .prototype property calcAge() &#123; console.log(2037 - this.birthYear); &#125; greet() &#123; console.log(`Hey $&#123;this.fullName&#125;`); &#125; get age() &#123; return 2037 - this.birthYear; &#125; // Set a property that already exists set fullName(name) &#123; if (name.includes(&#x27; &#x27;)) this._fullName = name; else alert(`$&#123;name&#125; is not a full name!`); &#125; get fullName() &#123; return this._fullName; &#125; // Static method static hey() &#123; console.log(&#x27;Hey there 👋&#x27;); console.log(this); &#125;&#125;const jessica = new PersonCl(&#x27;Jessica Davis&#x27;, 1996);console.log(jessica);jessica.calcAge();console.log(jessica.age);console.log(jessica.__proto__ === PersonCl.prototype); // true// PersonCl.prototype.greet = function () &#123;// console.log(`Hey $&#123;this.firstName&#125;`);// &#125;;jessica.greet(); Setters and GettersStatic Methods and Instance MethodsObject.create() 1234567891011121314151617181920212223// Object.createconst PersonProto = &#123; calcAge() &#123; console.log(2037 - this.birthYear); &#125;, init(firstName, birthYear) &#123; this.firstName = firstName; this.birthYear = birthYear; &#125;,&#125;;const steven = Object.create(PersonProto);console.log(steven);steven.name = &#x27;Steven&#x27;;steven.birthYear = 2002;steven.calcAge();console.log(steven.__proto__ === PersonProto); // trueconst sarah = Object.create(PersonProto);sarah.init(&#x27;Sarah&#x27;, 1979);sarah.calcAge(); Inheritance between Classes"},{"title":"Optional_Chaining","path":"/wiki/JavaScript/Optional_Chaining.html","content":"？Now if you want to know whether a restaurant’s opening hours in Monday 1console.log(restaurant.openingHours.mon); If mon is not exist, it will be undefined, not a big deal. But if openingHours is not exist ,it will be a error. So we can solve this problem with the ? 1console.log(restaurant.openingHours?.mon); We can also use it to use method. 1console.log(restaurant.order?.(0,1) ?? &#x27;Method does not exist.&#x27;)"},{"title":"Function","path":"/wiki/JavaScript/Functions.html","content":"FunctionsDefault ParametersWhy We Need It? If not 123456789101112const bookings = [];const createBooking = function (flightNum, numPassengers, price) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: undefined, price: undefined&#125; If you have 12345678910111213141516const bookings = [];const createBooking = function ( flightNum, numPassengers = 1, price = 199 * numPassengers) &#123; const booking = &#123; flightNum, numPassengers, price, &#125;; console.log(booking); bookings.push(booking);&#125;;createBooking(&#x27;LH123&#x27;);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 199&#125; If you want to skip some parameters, you can set it as undefined 12createBooking(&#x27;LH123&#x27;, undefined, 1000);//&#123;flightNum: &#x27;LH123&#x27;, numPassengers: 1, price: 1000&#125; How Passing Arguments Works:Value vs. ReferenceJavascript can only pass by value, no passing by reference. First-Class vs. Higher-ordered FunctionsFirst-Class Functions JavaScript treats functions as first-class citizens This means that functions are simply values Functions are just another “type” of object So we can: Store functions in variables or properties Passing functions as arguments to other functions Return functions from functions Call methods on functions Higher-Ordered FunctionsWhat is it? A function that receives another function as an argument ,that returns a new function, or both This is only possible because of first-class functions Why we need it a higher level of abstruction Functions Accepting Callback Functions123456789101112131415161718192021222324252627// Functions Accepting Callback Functionsconst oneWord = function (str) &#123; return str.replace(/ /g, &#x27;&#x27;).toLowerCase();&#125;;const upperFirstWord = function (str) &#123; const [first, ...others] = str.split(&#x27; &#x27;); return [first.toUpperCase(), ...others].join(&#x27; &#x27;);&#125;;// Higher-order functionconst transformer = function (str, fn) &#123; console.log(`Original string: $&#123;str&#125;`); console.log(`Transformed string: $&#123;fn(str)&#125;`); console.log(`Transformed by: $&#123;fn.name&#125;`);&#125;;transformer(&#x27;JavaScript is the best!&#x27;, upperFirstWord);transformer(&#x27;JavaScript is the best!&#x27;, oneWord);// JS uses callbacks all the timeconst high5 = function () &#123; console.log(&#x27;👋&#x27;);&#125;;document.body.addEventListener(&#x27;click&#x27;, high5);[&#x27;Jonas&#x27;, &#x27;Martha&#x27;, &#x27;Adam&#x27;].forEach(high5); Functions Ruturning functions12345678const greet = function (greeting) &#123; return function (name) &#123; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`); &#125;;&#125;;const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;);//Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;);//Hi, Aniya If you use the arrow function 1234const greet = greeting =&gt; name =&gt; console.log(`$&#123;greeting&#125;, $&#123;name&#125;`);const greetHi = greet(&#x27;Hi&#x27;);greetHi(&#x27;Conan&#x27;); //Hi, Conangreet(&#x27;Hi&#x27;)(&#x27;Aniya&#x27;); //Hi, Aniya Call()123456789101112131415161718192021const lufthansa = &#123; airline: &#x27;Lufthansa&#x27;, iataCode: &#x27;LH&#x27;, bookings: [], book(flightNum, name) &#123; console.log( `$&#123;name&#125; booked a seat on $&#123;this.airline&#125; flight $&#123;this.iataCode&#125;$&#123;flightNum&#125;` ); this.bookings.push(&#123; flight: `$&#123;this.iataCode&#125;$&#123;flightNum&#125;`, name &#125;); &#125;,&#125;;lufthansa.book(239, &#x27;Aniya&#x27;);const eurowings = &#123; airline: &#x27;eurowings&#x27;, name: &#x27;Eurowings&#x27;, iataCode: &#x27;EW&#x27;, bookings: [],&#125;;const book = lufthansa.book;book.call(eurowings, 23, &#x27;hai&#x27;); The first argument is the object that you want the this point to.The rest argument is the rest argument that the original the function need. apply()1book.apply(eurowings, [234, &#x27;ajdfhha&#x27;]); Difference: The second argument is an array,to accept origin arguments. Same as 1book.call(eurowings,...[234, &#x27;ajdfhha&#x27;]); bind()It will return a functions in which the this is the argument you passed in. 123book.bind(eurowings)(224, &#x27;asjf&#x27;);const bookEu = book.bind(eurowings);bookEu(2323, &#x27;asjfa&#x27;); Also, you can use it just like the call()method, passing in more arguments. If you don’t want to set this, just use null. Partial applicationwe can preset some arguments Immediately Invoked Function Expressions(IIFE)123(function () &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); Or 123(() =&gt; &#123; console.log(&#x27;Hello World!&#x27;);&#125;)(); You can not call it tiwice. Data Encapsulation and Data PrivacyClosuers A function always has access to the variable enviroment(VE) of the execution context in which it was created,even after that execution context was gone. Closure has priority over the scope chain. A closure gives a function access to all the variables of its parent function, even after that parent function has returned.The function keeps a reference to its outer scope, which preserves the scope chain all the time. Examples: let f; const g = function () &#123; const a = 1; f = function () &#123; console.log(a * 3); &#125;; &#125;; g(); f();//3 setTimeout()"},{"title":"Sets_and_Maps","path":"/wiki/JavaScript/Sets_and_Maps.html","content":"Sets and mapsIn ex6 ,two more data structures were finally introduced. Set is iterable SetsBasic usageUse new Set() to creat a new set. 12const set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);console.log(set);//Set(3) &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125; 12const set = new Set(&#x27;aniya&#x27;);console.log(set);//Set(4) &#123; &#x27;a&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;y&#x27; &#125; The input must be iterable. And the elements in a set is unique. And there is no order of the elements. No index. So there is no need to get a value form sets. Methods of set .size 12const set //4= new Set(&#x27;aniya&#x27;);console.log(set.size);//4 .has() 12const set = new Set(&#x27;aniya&#x27;);console.log(set.has(&#x27;a&#x27;), set.has(&#x27;0&#x27;));//true false To find out whether the set has the thing you want to know. .add() 1234const set = new Set();console.log(set);//Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set);//Set(1) &#123; &#x27;Tommy idiot&#x27; &#125; You can just add one at one time. .delete 123456const set = new Set();console.log(set); //Set(0) &#123;&#125;set.add(&#x27;Tommy idiot&#x27;);console.log(set); //Set(1) &#123; &#x27;Tommy idiot&#x27; &#125;set.delete(&#x27;Tommy idiot&#x27;);console.log(set);//Set(0) &#123;&#125; .clear() 123const set = new Set(&#x27;aniya&#x27;);set.clear();console.log(set);//Set(0) &#123;&#125; To clear out the set. Loop over the set12345678const set = new Set(&#x27;aniya&#x27;);for (const item of set) &#123; console.log(item);&#125;//a//n//i//y Some usecases of sets To remove duplicated values of arrarys. 123const arr = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4];const arrUnique = [...new Set(arr)];console.log(arrUnique);//[ 1, 2, 3, 4 ] And we can konw its size by the size method. Maps Maps is alike to objects,data are also stored as key-value pairs. The biggest diffrence is that keys in maps can be any type,such as number, string ,object and even another map. While the keys in objects can only be string. Creat a map1234567891011const question = new Map([ [&#x27;key&#x27;, &#x27;value&#x27;], [&#x27;question&#x27;, &quot;What&#x27;s the best programming language in the world?&quot;], [1, &#x27;C&#x27;], [2, &#x27;Java&#x27;], [3, &#x27;Javascript&#x27;], [&#x27;correct&#x27;, 3], [true, &#x27;Congratulations! 🤣&#x27;], [false, &#x27;Try again!😅&#x27;],]);console.log(question); The argument is a big arrary which contains many small arrarys which are compose of key-value pairs. .set()1234567891011121314let o = &#123; name: &#x27;jonas&#x27;,&#125;;const map = new Map();map.set(1, &#x27;the first&#x27;);map.set(&#x27;key&#x27;, 2);map.set(o, o);console.log(map.set(o, o));console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; Calling the set method like this does not only update the map that’s called on,but it also returns the map. So you can just do that like this: 1234567map.set(1, &#x27;the first&#x27;).set(o, o).set(&#x27;key&#x27;, 2);console.log(map);//Map(3) &#123; 1 =&gt; &#x27;the first&#x27;, &#x27;key&#x27; =&gt; 2, &#123; name: &#x27;jonas&#x27; &#125; =&gt; &#123; name: &#x27;jonas&#x27; &#125;&#125; .get()1console.log(map.get(&#x27;key&#x27;));//2 .has().delete()If you want to use an “Complex datatype” as an key ,you should store it in an variation first. Wrong 123const map = new Map();map.set([1, 2], &#x27;this&#x27;);console.log(map.get([1, 2]));//undefined Because the two [1,2] is not the same object that is stored in heap. Right 1234const map = new Map();const arr = [1, 2];map.set(arr, &#x27;this&#x27;);console.log(map.get(arr)); //this Convert a object into a map.1newMap = new Map(Object.entries(objectName)); Loop over a map123for(const [key,value] of mapName)&#123;\tconsole.log(key,value);&#125;"},{"title":"Spread_Operator","path":"/wiki/JavaScript/Spread_Operator.html","content":"Spread OperatorDeconstruct the values in the array, suitable for the comma separation (this applies to all iterables) Iterables:arrary, strings, maps, sets.Not objects Usually separated by commas: a function passes arguments, builds a new array 1234const arr = [7, 8, 9];const newArr = [1, 2, ...arr];console.log(newArr);//(5) [1, 2, 7, 8, 9]console.log(...newArr);//1 2 7 8 9 Application Shallow copy ``` jslet newArr = […oldArr];12345- Combine arrays - ``` js const Arr = [...Arr1,...Arr2]; 1console.log(...&quot;jonas&quot;);//j o n a s Specially Works for object, too. 1let newObj = &#123; ...oldObj,name:&quot;tom&quot;&#125; 以此来实现对象的浅拷贝 Rest PatternIt’s similar to the spread pattern, but the three dots are on the left. Example: 12const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);//1 2 (4) [3, 4, 5, 6] the Rest element must be the last one in []. Of course, object can use it too. In Function123456const [a, b, ...others] = [1, 2, 3, 4, 5, 6];console.log(a, b, others);const add = function (...numbers) &#123; console.log(numbers);&#125;;add(1, 2, 3, 45, 6, 56, 45, 755, 3, 57);//(10) [1, 2, 3, 45, 6, 56, 45, 755, 3, 57]"},{"title":"Which_Data_Structure_to_Use","path":"/wiki/JavaScript/Which_Data_Structure_to_Use.html","content":"Which data structure to use?Sourece Of Data From the program itself From the UI From external sources For Simple List: Arrays or SetsArrays Use when you need ordered list of values (might contain duplicates) Use when you need to manipulate data Sets Use when you need to work with unique values Use when high-performance is really important Use to remove duplicates from arrays For Key/Value Pairs: Objects or MapsObjects Features More “traditional” key/value store(“abused” objects) Easier to write and access values with . and [ ] Use when you need to include functions(methods) working with JSON(can convert to map) Maps Features Better performance Keys can have any data type Easy to iterate Easy to compute size Use when you simply need to map key to values you need keys that are not strings"},{"title":"前言","path":"/wiki/JavaScript/index.html","content":"听JS教程留下的一部分笔记 为了拯救我那很烂的英语🙌，笔记主要是英文（自己后来也可能看不懂🤣🤣 上传的第一篇笔记😎😎😎"},{"title":"String","path":"/wiki/JavaScript/Working_with_Strings.html","content":"Working With Stringsmethods Return new strings .length .indexOf() 123const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.indexOf(&#x27;Portugal&#x27;));//8console.log(airline.indexOf(&#x27;portugal&#x27;));//-1 ​ Case sensetive* .lastIndexOf() 12const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.lastIndexOf(&#x27;r&#x27;));//10 The last ‘r’. .slice() 1234const airline = &#x27;TAP Air Portugal&#x27;;console.log(airline.slice(4));//Air Portugalconsole.log(airline.slice(4, 7));//Airconsole.log(airline.slice(-2));//al It returns a new string. The end value is not included in the new string. When the argument is negative, it will count from the end. .toLowerCase() .toUpperCase() .trim() .replace() You can use regular expression here. 1console.log(airline.replaceAll(/A/g, &#x27;a&#x27;));//TaP air Portugal It replaced all ‘A’. .replaceAll() .repeat() 1234const planesInLine = function (n) &#123; console.log(`There are $&#123;n&#125; planes in line $&#123;&#x27;✈️&#x27;.repeat(n)&#125;`);&#125;;planesInLine(10);//There are 10 planes in line ✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️ Return booleans. .includes() .startsWith() endsWith() We do know that string is a type of primitives,why it has methods?Because javascript automaticlly will turn the string into an object,and when the operation is done, it will turn back into a string primitive. So all string methods return primitives, even if called on a string object. 12console.log(typeof new String(&#x27;aniya&#x27;)); //objectconsole.log(typeof new String(&#x27;aniya&#x27;).slice(-1));//string Other important method:split() join() split() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.split(&#x27;+&#x27;));//[ &#x27;qwer&#x27;, &#x27;zxcv&#x27;, &#x27;ajf0s&#x27;, &#x27;sjaf&#x27; ] join() ​ Input an array,return a string. 123const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;const strSplit = str.split(&#x27;+&#x27;);console.log(strSplit.join(&#x27;---&#x27;));//qwer---zxcv---ajf0s---sjaf Padding Methods padStart() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padStart(30, &#x27;)+&#x27;));//)+)+)+)+)+qwer+zxcv+ajf0s+sjaf padEnd() 12const str = &#x27;qwer+zxcv+ajf0s+sjaf&#x27;;console.log(str.padEnd(30, &#x27;)+&#x27;));//qwer+zxcv+ajf0s+sjaf)+)+)+)+)+"}]